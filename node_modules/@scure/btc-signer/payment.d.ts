import { type Coder } from '@scure/base';
import * as P from 'micro-packed';
import { type TransactionInput } from './psbt.ts';
import { type ScriptType } from './script.ts';
import { type BTC_NETWORK, type Bytes } from './utils.ts';
export type P2Ret = {
    type: string;
    script: Bytes;
    address?: string;
    redeemScript?: Bytes;
    witnessScript?: Bytes;
    hash?: Bytes;
};
type OutP2AType = {
    type: 'p2a';
    script: Bytes;
};
type OutPKType = {
    type: 'pk';
    pubkey: Bytes;
};
export type OptScript = ScriptType | undefined;
type OutPKHType = {
    type: 'pkh';
    hash: Bytes;
};
type OutSHType = {
    type: 'sh';
    hash: Bytes;
};
type OutWSHType = {
    type: 'wsh';
    hash: Bytes;
};
type OutWPKHType = {
    type: 'wpkh';
    hash: Bytes;
};
type OutMSType = {
    type: 'ms';
    pubkeys: Bytes[];
    m: number;
};
type OutTRType = {
    type: 'tr';
    pubkey: Bytes;
};
type OutTRNSType = {
    type: 'tr_ns';
    pubkeys: Bytes[];
};
type OutTRMSType = {
    type: 'tr_ms';
    pubkeys: Bytes[];
    m: number;
};
type OutUnknownType = {
    type: 'unknown';
    script: Bytes;
};
type FinalizeSignature = [{
    pubKey: Bytes;
    leafHash: Bytes;
}, Bytes];
type CustomScriptOut = {
    type: string;
} & Record<string, any>;
export type CustomScript = Coder<OptScript, CustomScriptOut | undefined> & {
    finalizeTaproot?: (script: Bytes, parsed: CustomScriptOut, signatures: FinalizeSignature[]) => Bytes[] | undefined;
};
export declare const OutScript: P.CoderType<NonNullable<OutP2AType | OutPKType | OutPKHType | OutSHType | OutWSHType | OutWPKHType | OutMSType | OutTRType | OutTRNSType | OutTRMSType | OutUnknownType | undefined>>;
export type OutScriptType = typeof OutScript;
export declare function checkScript(script?: Bytes, redeemScript?: Bytes, witnessScript?: Bytes): void;
type Extends<T, U> = T extends U ? T : never;
export type P2PK = {
    type: 'pk';
    script: Bytes;
};
export declare const p2pk: (pubkey: Bytes, _network?: BTC_NETWORK) => Extends<P2PK, P2Ret>;
export type P2PKH = {
    type: 'pkh';
    script: Bytes;
    address: string;
    hash: Bytes;
};
export declare const p2pkh: (publicKey: Bytes, network?: BTC_NETWORK) => Extends<P2PKH, P2Ret>;
export type P2SHBase = {
    type: 'sh';
    redeemScript: Bytes;
    script: Bytes;
    address: string;
    hash: Bytes;
};
export type P2SHWithWitness = P2SHBase & {
    witnessScript: Bytes;
};
export type P2SHWithoutWitness = Omit<P2SHBase, 'witnessScript'>;
export type P2SHReturn<T extends P2Ret> = T extends {
    witnessScript: Bytes;
} ? P2SHWithWitness : P2SHWithoutWitness;
export declare const p2sh: <T extends P2Ret>(child: T, network?: BTC_NETWORK) => Extends<P2SHReturn<T>, P2Ret>;
export type P2WSH = {
    type: 'wsh';
    witnessScript: Bytes;
    script: Bytes;
    address: string;
    hash: Bytes;
};
export declare const p2wsh: (child: P2Ret, network?: BTC_NETWORK) => Extends<P2WSH, P2Ret>;
export type P2WPKH = {
    type: 'wpkh';
    script: Bytes;
    address: string;
    hash: Bytes;
};
export declare const p2wpkh: (publicKey: Bytes, network?: BTC_NETWORK) => Extends<P2WPKH, P2Ret>;
export type P2MS = {
    type: 'ms';
    script: Bytes;
};
export declare const p2ms: (m: number, pubkeys: Bytes[], allowSamePubkeys?: boolean) => Extends<P2MS, P2Ret>;
export type HashedTree = {
    type: 'leaf';
    version?: number;
    script: Bytes;
    hash: Bytes;
} | {
    type: 'branch';
    left: HashedTree;
    right: HashedTree;
    hash: Bytes;
};
export type P2TR = {
    type: 'tr';
    script: Bytes;
    address: string;
    tweakedPubkey: Bytes;
    tapInternalKey: Bytes;
};
export type P2TR_TREE = P2TR & {
    tapMerkleRoot: Bytes;
    tapLeafScript: TransactionInput['tapLeafScript'];
    leaves: TaprootLeaf[];
};
export type TaprootNode = {
    script: Bytes | string;
    leafVersion?: number;
    weight?: number;
} & Partial<P2TR_TREE>;
export type TaprootScriptTree = TaprootNode | TaprootScriptTree[];
export type TaprootScriptList = TaprootNode[];
export declare function taprootListToTree(taprootList: TaprootScriptList): TaprootScriptTree;
export type TaprootLeaf = {
    type: 'leaf';
    version?: number;
    script: Bytes;
    hash: Bytes;
    path: Bytes[];
};
export type HashedTreeWithPath = TaprootLeaf | {
    type: 'branch';
    left: HashedTreeWithPath;
    right: HashedTreeWithPath;
    hash: Bytes;
    path: Bytes[];
};
export declare const TAP_LEAF_VERSION = 192;
export declare const tapLeafHash: (script: Bytes, version?: number) => Bytes;
export type P2TRRet<T> = T extends TaprootScriptTree ? P2TR_TREE : P2TR;
export declare function p2tr(internalPubKey: Bytes | string, tree?: undefined, network?: BTC_NETWORK, allowUnknownOutputs?: boolean, customScripts?: CustomScript[]): Extends<P2TR, P2Ret>;
export declare function p2tr(internalPubKey: Bytes | string, tree: TaprootScriptTree, network?: BTC_NETWORK, allowUnknownOutputs?: boolean, customScripts?: CustomScript[]): Extends<P2TR_TREE, P2Ret>;
export declare function combinations<T>(m: number, list: T[]): T[][];
/**
 * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.
 * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.
 * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`
 */
export type P2TR_NS = {
    type: 'tr_ns';
    script: Bytes;
};
export declare const p2tr_ns: (m: number, pubkeys: Bytes[], allowSamePubkeys?: boolean) => Extends<P2TR_NS, P2Ret>[];
export type P2TR_PK = P2TR_NS;
export declare const p2tr_pk: (pubkey: Bytes) => Extends<P2TR_PK, P2Ret>;
export type P2TR_MS = {
    type: 'tr_ms';
    script: Bytes;
};
export declare function p2tr_ms(m: number, pubkeys: Bytes[], allowSamePubkeys?: boolean): Extends<P2TR_MS, P2Ret>;
export declare function getAddress(type: 'pkh' | 'wpkh' | 'tr', privKey: Bytes, network?: BTC_NETWORK): string | undefined;
export declare const _sortPubkeys: (pubkeys: Bytes[]) => Bytes[];
export declare function multisig(m: number, pubkeys: Bytes[], sorted?: boolean, witness?: boolean, network?: BTC_NETWORK): P2Ret;
export declare function sortedMultisig(m: number, pubkeys: Bytes[], witness?: boolean, network?: BTC_NETWORK): P2Ret;
export declare function WIF(network?: BTC_NETWORK): Coder<Bytes, string>;
export declare function Address(network?: BTC_NETWORK): {
    encode(from: P.UnwrapCoder<OutScriptType>): string;
    decode(address: string): P.UnwrapCoder<OutScriptType>;
};
export {};
//# sourceMappingURL=payment.d.ts.map