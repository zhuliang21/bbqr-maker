/**
 * BTC P2P layer from BIP324.
 *
 * Experimental ElligatorSwift implementation:
 * Schnorr-like x-only ECDH with public keys indistinguishable from uniformly random bytes.
 *
 * Documented in
 * [BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki),
 * [libsecp](https://github.com/bitcoin/bitcoin/blob/master/src/secp256k1/doc/ellswift.md).
 *
 * SwiftEC: Shallue-van de Woestijne Indifferentiable Function to Elliptic Curves.
 * Documented in https://eprint.iacr.org/2022/759.pdf.
 *
 * Curve25519 & P-521 are incompatible with SwiftEC. Differences from SwiftEC:
 * * undefined inputs are remapped
 * * y-parity is encoded in u/t values
 *
 * @module
 */
import type { Hex } from '@noble/curves/abstract/utils.js';
import { type ProjPointType as PointType } from '@noble/curves/abstract/weierstrass.js';
/**
 * Experimental ElligatorSwift implementation:
 * Schnorr-like x-only ECDH with public keys indistinguishable from uniformly random bytes.
 * Documented in BIP324.
 */
export declare const elligatorSwift: {
    _inv: (x: bigint, u: bigint, ellCase: number) => bigint | void;
    encode: (x: bigint | PointType<bigint>) => Uint8Array;
    decode: (data: Hex) => Uint8Array;
    keygen: () => {
        privateKey: Uint8Array<ArrayBufferLike>;
        publicKey: Uint8Array<ArrayBufferLike>;
    };
    getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array<ArrayBufferLike>;
    getSharedSecretBip324: (privateKeyOurs: Hex, publicKeyTheirs: Hex, publicKeyOurs: Hex, initiating: boolean) => Uint8Array<ArrayBufferLike>;
};
//# sourceMappingURL=p2p.d.ts.map