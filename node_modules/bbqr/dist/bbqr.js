function Aa(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Tt = {}, yn, $r;
function ko() {
  return $r || ($r = 1, yn = function() {
    return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
  }), yn;
}
var An = {}, ot = {}, Pr;
function Et() {
  if (Pr) return ot;
  Pr = 1;
  let e;
  const r = [
    0,
    // Not used
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  return ot.getSymbolSize = function(i) {
    if (!i) throw new Error('"version" cannot be null or undefined');
    if (i < 1 || i > 40) throw new Error('"version" should be in range from 1 to 40');
    return i * 4 + 17;
  }, ot.getSymbolTotalCodewords = function(i) {
    return r[i];
  }, ot.getBCHDigit = function(t) {
    let i = 0;
    for (; t !== 0; )
      i++, t >>>= 1;
    return i;
  }, ot.setToSJISFunction = function(i) {
    if (typeof i != "function")
      throw new Error('"toSJISFunc" is not a valid function.');
    e = i;
  }, ot.isKanjiModeEnabled = function() {
    return typeof e < "u";
  }, ot.toSJIS = function(i) {
    return e(i);
  }, ot;
}
var Sn = {}, qr;
function Ir() {
  return qr || (qr = 1, function(e) {
    e.L = { bit: 1 }, e.M = { bit: 0 }, e.Q = { bit: 3 }, e.H = { bit: 2 };
    function r(t) {
      if (typeof t != "string")
        throw new Error("Param is not a string");
      switch (t.toLowerCase()) {
        case "l":
        case "low":
          return e.L;
        case "m":
        case "medium":
          return e.M;
        case "q":
        case "quartile":
          return e.Q;
        case "h":
        case "high":
          return e.H;
        default:
          throw new Error("Unknown EC Level: " + t);
      }
    }
    e.isValid = function(i) {
      return i && typeof i.bit < "u" && i.bit >= 0 && i.bit < 4;
    }, e.from = function(i, f) {
      if (e.isValid(i))
        return i;
      try {
        return r(i);
      } catch {
        return f;
      }
    };
  }(Sn)), Sn;
}
var Rn, Kr;
function mo() {
  if (Kr) return Rn;
  Kr = 1;
  function e() {
    this.buffer = [], this.length = 0;
  }
  return e.prototype = {
    get: function(r) {
      const t = Math.floor(r / 8);
      return (this.buffer[t] >>> 7 - r % 8 & 1) === 1;
    },
    put: function(r, t) {
      for (let i = 0; i < t; i++)
        this.putBit((r >>> t - i - 1 & 1) === 1);
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(r) {
      const t = Math.floor(this.length / 8);
      this.buffer.length <= t && this.buffer.push(0), r && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;
    }
  }, Rn = e, Rn;
}
var Tn, Yr;
function yo() {
  if (Yr) return Tn;
  Yr = 1;
  function e(r) {
    if (!r || r < 1)
      throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = r, this.data = new Uint8Array(r * r), this.reservedBit = new Uint8Array(r * r);
  }
  return e.prototype.set = function(r, t, i, f) {
    const n = r * this.size + t;
    this.data[n] = i, f && (this.reservedBit[n] = !0);
  }, e.prototype.get = function(r, t) {
    return this.data[r * this.size + t];
  }, e.prototype.xor = function(r, t, i) {
    this.data[r * this.size + t] ^= i;
  }, e.prototype.isReserved = function(r, t) {
    return this.reservedBit[r * this.size + t];
  }, Tn = e, Tn;
}
var zn = {}, Qr;
function Ao() {
  return Qr || (Qr = 1, function(e) {
    const r = Et().getSymbolSize;
    e.getRowColCoords = function(i) {
      if (i === 1) return [];
      const f = Math.floor(i / 7) + 2, n = r(i), a = n === 145 ? 26 : Math.ceil((n - 13) / (2 * f - 2)) * 2, l = [n - 7];
      for (let s = 1; s < f - 1; s++)
        l[s] = l[s - 1] - a;
      return l.push(6), l.reverse();
    }, e.getPositions = function(i) {
      const f = [], n = e.getRowColCoords(i), a = n.length;
      for (let l = 0; l < a; l++)
        for (let s = 0; s < a; s++)
          l === 0 && s === 0 || // top-left
          l === 0 && s === a - 1 || // bottom-left
          l === a - 1 && s === 0 || f.push([n[l], n[s]]);
      return f;
    };
  }(zn)), zn;
}
var Cn = {}, Vr;
function So() {
  if (Vr) return Cn;
  Vr = 1;
  const e = Et().getSymbolSize, r = 7;
  return Cn.getPositions = function(i) {
    const f = e(i);
    return [
      // top-left
      [0, 0],
      // top-right
      [f - r, 0],
      // bottom-left
      [0, f - r]
    ];
  }, Cn;
}
var In = {}, jr;
function Ro() {
  return jr || (jr = 1, function(e) {
    e.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    const r = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    e.isValid = function(f) {
      return f != null && f !== "" && !isNaN(f) && f >= 0 && f <= 7;
    }, e.from = function(f) {
      return e.isValid(f) ? parseInt(f, 10) : void 0;
    }, e.getPenaltyN1 = function(f) {
      const n = f.size;
      let a = 0, l = 0, s = 0, h = null, u = null;
      for (let d = 0; d < n; d++) {
        l = s = 0, h = u = null;
        for (let g = 0; g < n; g++) {
          let v = f.get(d, g);
          v === h ? l++ : (l >= 5 && (a += r.N1 + (l - 5)), h = v, l = 1), v = f.get(g, d), v === u ? s++ : (s >= 5 && (a += r.N1 + (s - 5)), u = v, s = 1);
        }
        l >= 5 && (a += r.N1 + (l - 5)), s >= 5 && (a += r.N1 + (s - 5));
      }
      return a;
    }, e.getPenaltyN2 = function(f) {
      const n = f.size;
      let a = 0;
      for (let l = 0; l < n - 1; l++)
        for (let s = 0; s < n - 1; s++) {
          const h = f.get(l, s) + f.get(l, s + 1) + f.get(l + 1, s) + f.get(l + 1, s + 1);
          (h === 4 || h === 0) && a++;
        }
      return a * r.N2;
    }, e.getPenaltyN3 = function(f) {
      const n = f.size;
      let a = 0, l = 0, s = 0;
      for (let h = 0; h < n; h++) {
        l = s = 0;
        for (let u = 0; u < n; u++)
          l = l << 1 & 2047 | f.get(h, u), u >= 10 && (l === 1488 || l === 93) && a++, s = s << 1 & 2047 | f.get(u, h), u >= 10 && (s === 1488 || s === 93) && a++;
      }
      return a * r.N3;
    }, e.getPenaltyN4 = function(f) {
      let n = 0;
      const a = f.data.length;
      for (let s = 0; s < a; s++) n += f.data[s];
      return Math.abs(Math.ceil(n * 100 / a / 5) - 10) * r.N4;
    };
    function t(i, f, n) {
      switch (i) {
        case e.Patterns.PATTERN000:
          return (f + n) % 2 === 0;
        case e.Patterns.PATTERN001:
          return f % 2 === 0;
        case e.Patterns.PATTERN010:
          return n % 3 === 0;
        case e.Patterns.PATTERN011:
          return (f + n) % 3 === 0;
        case e.Patterns.PATTERN100:
          return (Math.floor(f / 2) + Math.floor(n / 3)) % 2 === 0;
        case e.Patterns.PATTERN101:
          return f * n % 2 + f * n % 3 === 0;
        case e.Patterns.PATTERN110:
          return (f * n % 2 + f * n % 3) % 2 === 0;
        case e.Patterns.PATTERN111:
          return (f * n % 3 + (f + n) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + i);
      }
    }
    e.applyMask = function(f, n) {
      const a = n.size;
      for (let l = 0; l < a; l++)
        for (let s = 0; s < a; s++)
          n.isReserved(s, l) || n.xor(s, l, t(f, s, l));
    }, e.getBestMask = function(f, n) {
      const a = Object.keys(e.Patterns).length;
      let l = 0, s = 1 / 0;
      for (let h = 0; h < a; h++) {
        n(h), e.applyMask(h, f);
        const u = e.getPenaltyN1(f) + e.getPenaltyN2(f) + e.getPenaltyN3(f) + e.getPenaltyN4(f);
        e.applyMask(h, f), u < s && (s = u, l = h);
      }
      return l;
    };
  }(In)), In;
}
var ln = {}, Xr;
function Sa() {
  if (Xr) return ln;
  Xr = 1;
  const e = Ir(), r = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ], t = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  return ln.getBlocksCount = function(f, n) {
    switch (n) {
      case e.L:
        return r[(f - 1) * 4 + 0];
      case e.M:
        return r[(f - 1) * 4 + 1];
      case e.Q:
        return r[(f - 1) * 4 + 2];
      case e.H:
        return r[(f - 1) * 4 + 3];
      default:
        return;
    }
  }, ln.getTotalCodewordsCount = function(f, n) {
    switch (n) {
      case e.L:
        return t[(f - 1) * 4 + 0];
      case e.M:
        return t[(f - 1) * 4 + 1];
      case e.Q:
        return t[(f - 1) * 4 + 2];
      case e.H:
        return t[(f - 1) * 4 + 3];
      default:
        return;
    }
  }, ln;
}
var Dn = {}, Ht = {}, Jr;
function To() {
  if (Jr) return Ht;
  Jr = 1;
  const e = new Uint8Array(512), r = new Uint8Array(256);
  return function() {
    let i = 1;
    for (let f = 0; f < 255; f++)
      e[f] = i, r[i] = f, i <<= 1, i & 256 && (i ^= 285);
    for (let f = 255; f < 512; f++)
      e[f] = e[f - 255];
  }(), Ht.log = function(i) {
    if (i < 1) throw new Error("log(" + i + ")");
    return r[i];
  }, Ht.exp = function(i) {
    return e[i];
  }, Ht.mul = function(i, f) {
    return i === 0 || f === 0 ? 0 : e[r[i] + r[f]];
  }, Ht;
}
var Wr;
function zo() {
  return Wr || (Wr = 1, function(e) {
    const r = To();
    e.mul = function(i, f) {
      const n = new Uint8Array(i.length + f.length - 1);
      for (let a = 0; a < i.length; a++)
        for (let l = 0; l < f.length; l++)
          n[a + l] ^= r.mul(i[a], f[l]);
      return n;
    }, e.mod = function(i, f) {
      let n = new Uint8Array(i);
      for (; n.length - f.length >= 0; ) {
        const a = n[0];
        for (let s = 0; s < f.length; s++)
          n[s] ^= r.mul(f[s], a);
        let l = 0;
        for (; l < n.length && n[l] === 0; ) l++;
        n = n.slice(l);
      }
      return n;
    }, e.generateECPolynomial = function(i) {
      let f = new Uint8Array([1]);
      for (let n = 0; n < i; n++)
        f = e.mul(f, new Uint8Array([1, r.exp(n)]));
      return f;
    };
  }(Dn)), Dn;
}
var Ln, Gr;
function Co() {
  if (Gr) return Ln;
  Gr = 1;
  const e = zo();
  function r(t) {
    this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree);
  }
  return r.prototype.initialize = function(i) {
    this.degree = i, this.genPoly = e.generateECPolynomial(this.degree);
  }, r.prototype.encode = function(i) {
    if (!this.genPoly)
      throw new Error("Encoder not initialized");
    const f = new Uint8Array(i.length + this.degree);
    f.set(i);
    const n = e.mod(f, this.genPoly), a = this.degree - n.length;
    if (a > 0) {
      const l = new Uint8Array(this.degree);
      return l.set(n, a), l;
    }
    return n;
  }, Ln = r, Ln;
}
var Bn = {}, Mn = {}, Nn = {}, ei;
function Ra() {
  return ei || (ei = 1, Nn.isValid = function(r) {
    return !isNaN(r) && r >= 1 && r <= 40;
  }), Nn;
}
var Qe = {}, ti;
function Ta() {
  if (ti) return Qe;
  ti = 1;
  const e = "[0-9]+", r = "[A-Z $%*+\\-./:]+";
  let t = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  t = t.replace(/u/g, "\\u");
  const i = "(?:(?![A-Z0-9 $%*+\\-./:]|" + t + `)(?:.|[\r
]))+`;
  Qe.KANJI = new RegExp(t, "g"), Qe.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), Qe.BYTE = new RegExp(i, "g"), Qe.NUMERIC = new RegExp(e, "g"), Qe.ALPHANUMERIC = new RegExp(r, "g");
  const f = new RegExp("^" + t + "$"), n = new RegExp("^" + e + "$"), a = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  return Qe.testKanji = function(s) {
    return f.test(s);
  }, Qe.testNumeric = function(s) {
    return n.test(s);
  }, Qe.testAlphanumeric = function(s) {
    return a.test(s);
  }, Qe;
}
var ni;
function kt() {
  return ni || (ni = 1, function(e) {
    const r = Ra(), t = Ta();
    e.NUMERIC = {
      id: "Numeric",
      bit: 1,
      ccBits: [10, 12, 14]
    }, e.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 2,
      ccBits: [9, 11, 13]
    }, e.BYTE = {
      id: "Byte",
      bit: 4,
      ccBits: [8, 16, 16]
    }, e.KANJI = {
      id: "Kanji",
      bit: 8,
      ccBits: [8, 10, 12]
    }, e.MIXED = {
      bit: -1
    }, e.getCharCountIndicator = function(n, a) {
      if (!n.ccBits) throw new Error("Invalid mode: " + n);
      if (!r.isValid(a))
        throw new Error("Invalid version: " + a);
      return a >= 1 && a < 10 ? n.ccBits[0] : a < 27 ? n.ccBits[1] : n.ccBits[2];
    }, e.getBestModeForData = function(n) {
      return t.testNumeric(n) ? e.NUMERIC : t.testAlphanumeric(n) ? e.ALPHANUMERIC : t.testKanji(n) ? e.KANJI : e.BYTE;
    }, e.toString = function(n) {
      if (n && n.id) return n.id;
      throw new Error("Invalid mode");
    }, e.isValid = function(n) {
      return n && n.bit && n.ccBits;
    };
    function i(f) {
      if (typeof f != "string")
        throw new Error("Param is not a string");
      switch (f.toLowerCase()) {
        case "numeric":
          return e.NUMERIC;
        case "alphanumeric":
          return e.ALPHANUMERIC;
        case "kanji":
          return e.KANJI;
        case "byte":
          return e.BYTE;
        default:
          throw new Error("Unknown mode: " + f);
      }
    }
    e.from = function(n, a) {
      if (e.isValid(n))
        return n;
      try {
        return i(n);
      } catch {
        return a;
      }
    };
  }(Mn)), Mn;
}
var ri;
function Io() {
  return ri || (ri = 1, function(e) {
    const r = Et(), t = Sa(), i = Ir(), f = kt(), n = Ra(), a = 7973, l = r.getBCHDigit(a);
    function s(g, v, c) {
      for (let R = 1; R <= 40; R++)
        if (v <= e.getCapacity(R, c, g))
          return R;
    }
    function h(g, v) {
      return f.getCharCountIndicator(g, v) + 4;
    }
    function u(g, v) {
      let c = 0;
      return g.forEach(function(R) {
        const S = h(R.mode, v);
        c += S + R.getBitsLength();
      }), c;
    }
    function d(g, v) {
      for (let c = 1; c <= 40; c++)
        if (u(g, c) <= e.getCapacity(c, v, f.MIXED))
          return c;
    }
    e.from = function(v, c) {
      return n.isValid(v) ? parseInt(v, 10) : c;
    }, e.getCapacity = function(v, c, R) {
      if (!n.isValid(v))
        throw new Error("Invalid QR Code version");
      typeof R > "u" && (R = f.BYTE);
      const S = r.getSymbolTotalCodewords(v), b = t.getTotalCodewordsCount(v, c), x = (S - b) * 8;
      if (R === f.MIXED) return x;
      const m = x - h(R, v);
      switch (R) {
        case f.NUMERIC:
          return Math.floor(m / 10 * 3);
        case f.ALPHANUMERIC:
          return Math.floor(m / 11 * 2);
        case f.KANJI:
          return Math.floor(m / 13);
        case f.BYTE:
        default:
          return Math.floor(m / 8);
      }
    }, e.getBestVersionForData = function(v, c) {
      let R;
      const S = i.from(c, i.M);
      if (Array.isArray(v)) {
        if (v.length > 1)
          return d(v, S);
        if (v.length === 0)
          return 1;
        R = v[0];
      } else
        R = v;
      return s(R.mode, R.getLength(), S);
    }, e.getEncodedBits = function(v) {
      if (!n.isValid(v) || v < 7)
        throw new Error("Invalid QR Code version");
      let c = v << 12;
      for (; r.getBCHDigit(c) - l >= 0; )
        c ^= a << r.getBCHDigit(c) - l;
      return v << 12 | c;
    };
  }(Bn)), Bn;
}
var Zn = {}, ii;
function Do() {
  if (ii) return Zn;
  ii = 1;
  const e = Et(), r = 1335, t = 21522, i = e.getBCHDigit(r);
  return Zn.getEncodedBits = function(n, a) {
    const l = n.bit << 3 | a;
    let s = l << 10;
    for (; e.getBCHDigit(s) - i >= 0; )
      s ^= r << e.getBCHDigit(s) - i;
    return (l << 10 | s) ^ t;
  }, Zn;
}
var On = {}, Hn, ai;
function Lo() {
  if (ai) return Hn;
  ai = 1;
  const e = kt();
  function r(t) {
    this.mode = e.NUMERIC, this.data = t.toString();
  }
  return r.getBitsLength = function(i) {
    return 10 * Math.floor(i / 3) + (i % 3 ? i % 3 * 3 + 1 : 0);
  }, r.prototype.getLength = function() {
    return this.data.length;
  }, r.prototype.getBitsLength = function() {
    return r.getBitsLength(this.data.length);
  }, r.prototype.write = function(i) {
    let f, n, a;
    for (f = 0; f + 3 <= this.data.length; f += 3)
      n = this.data.substr(f, 3), a = parseInt(n, 10), i.put(a, 10);
    const l = this.data.length - f;
    l > 0 && (n = this.data.substr(f), a = parseInt(n, 10), i.put(a, l * 3 + 1));
  }, Hn = r, Hn;
}
var Un, oi;
function Bo() {
  if (oi) return Un;
  oi = 1;
  const e = kt(), r = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function t(i) {
    this.mode = e.ALPHANUMERIC, this.data = i;
  }
  return t.getBitsLength = function(f) {
    return 11 * Math.floor(f / 2) + 6 * (f % 2);
  }, t.prototype.getLength = function() {
    return this.data.length;
  }, t.prototype.getBitsLength = function() {
    return t.getBitsLength(this.data.length);
  }, t.prototype.write = function(f) {
    let n;
    for (n = 0; n + 2 <= this.data.length; n += 2) {
      let a = r.indexOf(this.data[n]) * 45;
      a += r.indexOf(this.data[n + 1]), f.put(a, 11);
    }
    this.data.length % 2 && f.put(r.indexOf(this.data[n]), 6);
  }, Un = t, Un;
}
var Fn, fi;
function Mo() {
  if (fi) return Fn;
  fi = 1;
  const e = kt();
  function r(t) {
    this.mode = e.BYTE, typeof t == "string" ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t);
  }
  return r.getBitsLength = function(i) {
    return i * 8;
  }, r.prototype.getLength = function() {
    return this.data.length;
  }, r.prototype.getBitsLength = function() {
    return r.getBitsLength(this.data.length);
  }, r.prototype.write = function(t) {
    for (let i = 0, f = this.data.length; i < f; i++)
      t.put(this.data[i], 8);
  }, Fn = r, Fn;
}
var $n, li;
function No() {
  if (li) return $n;
  li = 1;
  const e = kt(), r = Et();
  function t(i) {
    this.mode = e.KANJI, this.data = i;
  }
  return t.getBitsLength = function(f) {
    return f * 13;
  }, t.prototype.getLength = function() {
    return this.data.length;
  }, t.prototype.getBitsLength = function() {
    return t.getBitsLength(this.data.length);
  }, t.prototype.write = function(i) {
    let f;
    for (f = 0; f < this.data.length; f++) {
      let n = r.toSJIS(this.data[f]);
      if (n >= 33088 && n <= 40956)
        n -= 33088;
      else if (n >= 57408 && n <= 60351)
        n -= 49472;
      else
        throw new Error(
          "Invalid SJIS character: " + this.data[f] + `
Make sure your charset is UTF-8`
        );
      n = (n >>> 8 & 255) * 192 + (n & 255), i.put(n, 13);
    }
  }, $n = t, $n;
}
var Pn = { exports: {} }, si;
function Zo() {
  return si || (si = 1, function(e) {
    var r = {
      single_source_shortest_paths: function(t, i, f) {
        var n = {}, a = {};
        a[i] = 0;
        var l = r.PriorityQueue.make();
        l.push(i, 0);
        for (var s, h, u, d, g, v, c, R, S; !l.empty(); ) {
          s = l.pop(), h = s.value, d = s.cost, g = t[h] || {};
          for (u in g)
            g.hasOwnProperty(u) && (v = g[u], c = d + v, R = a[u], S = typeof a[u] > "u", (S || R > c) && (a[u] = c, l.push(u, c), n[u] = h));
        }
        if (typeof f < "u" && typeof a[f] > "u") {
          var b = ["Could not find a path from ", i, " to ", f, "."].join("");
          throw new Error(b);
        }
        return n;
      },
      extract_shortest_path_from_predecessor_list: function(t, i) {
        for (var f = [], n = i; n; )
          f.push(n), t[n], n = t[n];
        return f.reverse(), f;
      },
      find_path: function(t, i, f) {
        var n = r.single_source_shortest_paths(t, i, f);
        return r.extract_shortest_path_from_predecessor_list(
          n,
          f
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(t) {
          var i = r.PriorityQueue, f = {}, n;
          t = t || {};
          for (n in i)
            i.hasOwnProperty(n) && (f[n] = i[n]);
          return f.queue = [], f.sorter = t.sorter || i.default_sorter, f;
        },
        default_sorter: function(t, i) {
          return t.cost - i.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(t, i) {
          var f = { value: t, cost: i };
          this.queue.push(f), this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    e.exports = r;
  }(Pn)), Pn.exports;
}
var hi;
function Oo() {
  return hi || (hi = 1, function(e) {
    const r = kt(), t = Lo(), i = Bo(), f = Mo(), n = No(), a = Ta(), l = Et(), s = Zo();
    function h(b) {
      return unescape(encodeURIComponent(b)).length;
    }
    function u(b, x, m) {
      const k = [];
      let L;
      for (; (L = b.exec(m)) !== null; )
        k.push({
          data: L[0],
          index: L.index,
          mode: x,
          length: L[0].length
        });
      return k;
    }
    function d(b) {
      const x = u(a.NUMERIC, r.NUMERIC, b), m = u(a.ALPHANUMERIC, r.ALPHANUMERIC, b);
      let k, L;
      return l.isKanjiModeEnabled() ? (k = u(a.BYTE, r.BYTE, b), L = u(a.KANJI, r.KANJI, b)) : (k = u(a.BYTE_KANJI, r.BYTE, b), L = []), x.concat(m, k, L).sort(function(E, T) {
        return E.index - T.index;
      }).map(function(E) {
        return {
          data: E.data,
          mode: E.mode,
          length: E.length
        };
      });
    }
    function g(b, x) {
      switch (x) {
        case r.NUMERIC:
          return t.getBitsLength(b);
        case r.ALPHANUMERIC:
          return i.getBitsLength(b);
        case r.KANJI:
          return n.getBitsLength(b);
        case r.BYTE:
          return f.getBitsLength(b);
      }
    }
    function v(b) {
      return b.reduce(function(x, m) {
        const k = x.length - 1 >= 0 ? x[x.length - 1] : null;
        return k && k.mode === m.mode ? (x[x.length - 1].data += m.data, x) : (x.push(m), x);
      }, []);
    }
    function c(b) {
      const x = [];
      for (let m = 0; m < b.length; m++) {
        const k = b[m];
        switch (k.mode) {
          case r.NUMERIC:
            x.push([
              k,
              { data: k.data, mode: r.ALPHANUMERIC, length: k.length },
              { data: k.data, mode: r.BYTE, length: k.length }
            ]);
            break;
          case r.ALPHANUMERIC:
            x.push([
              k,
              { data: k.data, mode: r.BYTE, length: k.length }
            ]);
            break;
          case r.KANJI:
            x.push([
              k,
              { data: k.data, mode: r.BYTE, length: h(k.data) }
            ]);
            break;
          case r.BYTE:
            x.push([
              { data: k.data, mode: r.BYTE, length: h(k.data) }
            ]);
        }
      }
      return x;
    }
    function R(b, x) {
      const m = {}, k = { start: {} };
      let L = ["start"];
      for (let z = 0; z < b.length; z++) {
        const E = b[z], T = [];
        for (let I = 0; I < E.length; I++) {
          const D = E[I], C = "" + z + I;
          T.push(C), m[C] = { node: D, lastCount: 0 }, k[C] = {};
          for (let O = 0; O < L.length; O++) {
            const N = L[O];
            m[N] && m[N].node.mode === D.mode ? (k[N][C] = g(m[N].lastCount + D.length, D.mode) - g(m[N].lastCount, D.mode), m[N].lastCount += D.length) : (m[N] && (m[N].lastCount = D.length), k[N][C] = g(D.length, D.mode) + 4 + r.getCharCountIndicator(D.mode, x));
          }
        }
        L = T;
      }
      for (let z = 0; z < L.length; z++)
        k[L[z]].end = 0;
      return { map: k, table: m };
    }
    function S(b, x) {
      let m;
      const k = r.getBestModeForData(b);
      if (m = r.from(x, k), m !== r.BYTE && m.bit < k.bit)
        throw new Error('"' + b + '" cannot be encoded with mode ' + r.toString(m) + `.
 Suggested mode is: ` + r.toString(k));
      switch (m === r.KANJI && !l.isKanjiModeEnabled() && (m = r.BYTE), m) {
        case r.NUMERIC:
          return new t(b);
        case r.ALPHANUMERIC:
          return new i(b);
        case r.KANJI:
          return new n(b);
        case r.BYTE:
          return new f(b);
      }
    }
    e.fromArray = function(x) {
      return x.reduce(function(m, k) {
        return typeof k == "string" ? m.push(S(k, null)) : k.data && m.push(S(k.data, k.mode)), m;
      }, []);
    }, e.fromString = function(x, m) {
      const k = d(x, l.isKanjiModeEnabled()), L = c(k), z = R(L, m), E = s.find_path(z.map, "start", "end"), T = [];
      for (let I = 1; I < E.length - 1; I++)
        T.push(z.table[E[I]].node);
      return e.fromArray(v(T));
    }, e.rawSplit = function(x) {
      return e.fromArray(
        d(x, l.isKanjiModeEnabled())
      );
    };
  }(On)), On;
}
var ui;
function Ho() {
  if (ui) return An;
  ui = 1;
  const e = Et(), r = Ir(), t = mo(), i = yo(), f = Ao(), n = So(), a = Ro(), l = Sa(), s = Co(), h = Io(), u = Do(), d = kt(), g = Oo();
  function v(z, E) {
    const T = z.size, I = n.getPositions(E);
    for (let D = 0; D < I.length; D++) {
      const C = I[D][0], O = I[D][1];
      for (let N = -1; N <= 7; N++)
        if (!(C + N <= -1 || T <= C + N))
          for (let U = -1; U <= 7; U++)
            O + U <= -1 || T <= O + U || (N >= 0 && N <= 6 && (U === 0 || U === 6) || U >= 0 && U <= 6 && (N === 0 || N === 6) || N >= 2 && N <= 4 && U >= 2 && U <= 4 ? z.set(C + N, O + U, !0, !0) : z.set(C + N, O + U, !1, !0));
    }
  }
  function c(z) {
    const E = z.size;
    for (let T = 8; T < E - 8; T++) {
      const I = T % 2 === 0;
      z.set(T, 6, I, !0), z.set(6, T, I, !0);
    }
  }
  function R(z, E) {
    const T = f.getPositions(E);
    for (let I = 0; I < T.length; I++) {
      const D = T[I][0], C = T[I][1];
      for (let O = -2; O <= 2; O++)
        for (let N = -2; N <= 2; N++)
          O === -2 || O === 2 || N === -2 || N === 2 || O === 0 && N === 0 ? z.set(D + O, C + N, !0, !0) : z.set(D + O, C + N, !1, !0);
    }
  }
  function S(z, E) {
    const T = z.size, I = h.getEncodedBits(E);
    let D, C, O;
    for (let N = 0; N < 18; N++)
      D = Math.floor(N / 3), C = N % 3 + T - 8 - 3, O = (I >> N & 1) === 1, z.set(D, C, O, !0), z.set(C, D, O, !0);
  }
  function b(z, E, T) {
    const I = z.size, D = u.getEncodedBits(E, T);
    let C, O;
    for (C = 0; C < 15; C++)
      O = (D >> C & 1) === 1, C < 6 ? z.set(C, 8, O, !0) : C < 8 ? z.set(C + 1, 8, O, !0) : z.set(I - 15 + C, 8, O, !0), C < 8 ? z.set(8, I - C - 1, O, !0) : C < 9 ? z.set(8, 15 - C - 1 + 1, O, !0) : z.set(8, 15 - C - 1, O, !0);
    z.set(I - 8, 8, 1, !0);
  }
  function x(z, E) {
    const T = z.size;
    let I = -1, D = T - 1, C = 7, O = 0;
    for (let N = T - 1; N > 0; N -= 2)
      for (N === 6 && N--; ; ) {
        for (let U = 0; U < 2; U++)
          if (!z.isReserved(D, N - U)) {
            let X = !1;
            O < E.length && (X = (E[O] >>> C & 1) === 1), z.set(D, N - U, X), C--, C === -1 && (O++, C = 7);
          }
        if (D += I, D < 0 || T <= D) {
          D -= I, I = -I;
          break;
        }
      }
  }
  function m(z, E, T) {
    const I = new t();
    T.forEach(function(U) {
      I.put(U.mode.bit, 4), I.put(U.getLength(), d.getCharCountIndicator(U.mode, z)), U.write(I);
    });
    const D = e.getSymbolTotalCodewords(z), C = l.getTotalCodewordsCount(z, E), O = (D - C) * 8;
    for (I.getLengthInBits() + 4 <= O && I.put(0, 4); I.getLengthInBits() % 8 !== 0; )
      I.putBit(0);
    const N = (O - I.getLengthInBits()) / 8;
    for (let U = 0; U < N; U++)
      I.put(U % 2 ? 17 : 236, 8);
    return k(I, z, E);
  }
  function k(z, E, T) {
    const I = e.getSymbolTotalCodewords(E), D = l.getTotalCodewordsCount(E, T), C = I - D, O = l.getBlocksCount(E, T), N = I % O, U = O - N, X = Math.floor(I / O), Y = Math.floor(C / O), q = Y + 1, V = X - Y, ne = new s(V);
    let ve = 0;
    const be = new Array(O), de = new Array(O);
    let he = 0;
    const ge = new Uint8Array(z.buffer);
    for (let W = 0; W < O; W++) {
      const Ee = W < U ? Y : q;
      be[W] = ge.slice(ve, ve + Ee), de[W] = ne.encode(be[W]), ve += Ee, he = Math.max(he, Ee);
    }
    const ue = new Uint8Array(I);
    let re = 0, ie, G;
    for (ie = 0; ie < he; ie++)
      for (G = 0; G < O; G++)
        ie < be[G].length && (ue[re++] = be[G][ie]);
    for (ie = 0; ie < V; ie++)
      for (G = 0; G < O; G++)
        ue[re++] = de[G][ie];
    return ue;
  }
  function L(z, E, T, I) {
    let D;
    if (Array.isArray(z))
      D = g.fromArray(z);
    else if (typeof z == "string") {
      let X = E;
      if (!X) {
        const Y = g.rawSplit(z);
        X = h.getBestVersionForData(Y, T);
      }
      D = g.fromString(z, X || 40);
    } else
      throw new Error("Invalid data");
    const C = h.getBestVersionForData(D, T);
    if (!C)
      throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!E)
      E = C;
    else if (E < C)
      throw new Error(
        `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + C + `.
`
      );
    const O = m(E, T, D), N = e.getSymbolSize(E), U = new i(N);
    return v(U, E), c(U), R(U, E), b(U, T, 0), E >= 7 && S(U, E), x(U, O), isNaN(I) && (I = a.getBestMask(
      U,
      b.bind(null, U, T)
    )), a.applyMask(I, U), b(U, T, I), {
      modules: U,
      version: E,
      errorCorrectionLevel: T,
      maskPattern: I,
      segments: D
    };
  }
  return An.create = function(E, T) {
    if (typeof E > "u" || E === "")
      throw new Error("No input text");
    let I = r.M, D, C;
    return typeof T < "u" && (I = r.from(T.errorCorrectionLevel, r.M), D = h.from(T.version), C = a.from(T.maskPattern), T.toSJISFunc && e.setToSJISFunction(T.toSJISFunc)), L(E, D, I, C);
  }, An;
}
var qn = {}, Kn = {}, ci;
function za() {
  return ci || (ci = 1, function(e) {
    function r(t) {
      if (typeof t == "number" && (t = t.toString()), typeof t != "string")
        throw new Error("Color should be defined as hex string");
      let i = t.slice().replace("#", "").split("");
      if (i.length < 3 || i.length === 5 || i.length > 8)
        throw new Error("Invalid hex color: " + t);
      (i.length === 3 || i.length === 4) && (i = Array.prototype.concat.apply([], i.map(function(n) {
        return [n, n];
      }))), i.length === 6 && i.push("F", "F");
      const f = parseInt(i.join(""), 16);
      return {
        r: f >> 24 & 255,
        g: f >> 16 & 255,
        b: f >> 8 & 255,
        a: f & 255,
        hex: "#" + i.slice(0, 6).join("")
      };
    }
    e.getOptions = function(i) {
      i || (i = {}), i.color || (i.color = {});
      const f = typeof i.margin > "u" || i.margin === null || i.margin < 0 ? 4 : i.margin, n = i.width && i.width >= 21 ? i.width : void 0, a = i.scale || 4;
      return {
        width: n,
        scale: n ? 4 : a,
        margin: f,
        color: {
          dark: r(i.color.dark || "#000000ff"),
          light: r(i.color.light || "#ffffffff")
        },
        type: i.type,
        rendererOpts: i.rendererOpts || {}
      };
    }, e.getScale = function(i, f) {
      return f.width && f.width >= i + f.margin * 2 ? f.width / (i + f.margin * 2) : f.scale;
    }, e.getImageWidth = function(i, f) {
      const n = e.getScale(i, f);
      return Math.floor((i + f.margin * 2) * n);
    }, e.qrToImageData = function(i, f, n) {
      const a = f.modules.size, l = f.modules.data, s = e.getScale(a, n), h = Math.floor((a + n.margin * 2) * s), u = n.margin * s, d = [n.color.light, n.color.dark];
      for (let g = 0; g < h; g++)
        for (let v = 0; v < h; v++) {
          let c = (g * h + v) * 4, R = n.color.light;
          if (g >= u && v >= u && g < h - u && v < h - u) {
            const S = Math.floor((g - u) / s), b = Math.floor((v - u) / s);
            R = d[l[S * a + b] ? 1 : 0];
          }
          i[c++] = R.r, i[c++] = R.g, i[c++] = R.b, i[c] = R.a;
        }
    };
  }(Kn)), Kn;
}
var di;
function Uo() {
  return di || (di = 1, function(e) {
    const r = za();
    function t(f, n, a) {
      f.clearRect(0, 0, n.width, n.height), n.style || (n.style = {}), n.height = a, n.width = a, n.style.height = a + "px", n.style.width = a + "px";
    }
    function i() {
      try {
        return document.createElement("canvas");
      } catch {
        throw new Error("You need to specify a canvas element");
      }
    }
    e.render = function(n, a, l) {
      let s = l, h = a;
      typeof s > "u" && (!a || !a.getContext) && (s = a, a = void 0), a || (h = i()), s = r.getOptions(s);
      const u = r.getImageWidth(n.modules.size, s), d = h.getContext("2d"), g = d.createImageData(u, u);
      return r.qrToImageData(g.data, n, s), t(d, h, u), d.putImageData(g, 0, 0), h;
    }, e.renderToDataURL = function(n, a, l) {
      let s = l;
      typeof s > "u" && (!a || !a.getContext) && (s = a, a = void 0), s || (s = {});
      const h = e.render(n, a, s), u = s.type || "image/png", d = s.rendererOpts || {};
      return h.toDataURL(u, d.quality);
    };
  }(qn)), qn;
}
var Yn = {}, _i;
function Fo() {
  if (_i) return Yn;
  _i = 1;
  const e = za();
  function r(f, n) {
    const a = f.a / 255, l = n + '="' + f.hex + '"';
    return a < 1 ? l + " " + n + '-opacity="' + a.toFixed(2).slice(1) + '"' : l;
  }
  function t(f, n, a) {
    let l = f + n;
    return typeof a < "u" && (l += " " + a), l;
  }
  function i(f, n, a) {
    let l = "", s = 0, h = !1, u = 0;
    for (let d = 0; d < f.length; d++) {
      const g = Math.floor(d % n), v = Math.floor(d / n);
      !g && !h && (h = !0), f[d] ? (u++, d > 0 && g > 0 && f[d - 1] || (l += h ? t("M", g + a, 0.5 + v + a) : t("m", s, 0), s = 0, h = !1), g + 1 < n && f[d + 1] || (l += t("h", u), u = 0)) : s++;
    }
    return l;
  }
  return Yn.render = function(n, a, l) {
    const s = e.getOptions(a), h = n.modules.size, u = n.modules.data, d = h + s.margin * 2, g = s.color.light.a ? "<path " + r(s.color.light, "fill") + ' d="M0 0h' + d + "v" + d + 'H0z"/>' : "", v = "<path " + r(s.color.dark, "stroke") + ' d="' + i(u, h, s.margin) + '"/>', c = 'viewBox="0 0 ' + d + " " + d + '"', S = '<svg xmlns="http://www.w3.org/2000/svg" ' + (s.width ? 'width="' + s.width + '" height="' + s.width + '" ' : "") + c + ' shape-rendering="crispEdges">' + g + v + `</svg>
`;
    return typeof l == "function" && l(null, S), S;
  }, Yn;
}
var gi;
function $o() {
  if (gi) return Tt;
  gi = 1;
  const e = ko(), r = Ho(), t = Uo(), i = Fo();
  function f(n, a, l, s, h) {
    const u = [].slice.call(arguments, 1), d = u.length, g = typeof u[d - 1] == "function";
    if (!g && !e())
      throw new Error("Callback required as last argument");
    if (g) {
      if (d < 2)
        throw new Error("Too few arguments provided");
      d === 2 ? (h = l, l = a, a = s = void 0) : d === 3 && (a.getContext && typeof h > "u" ? (h = s, s = void 0) : (h = s, s = l, l = a, a = void 0));
    } else {
      if (d < 1)
        throw new Error("Too few arguments provided");
      return d === 1 ? (l = a, a = s = void 0) : d === 2 && !a.getContext && (s = l, l = a, a = void 0), new Promise(function(v, c) {
        try {
          const R = r.create(l, s);
          v(n(R, a, s));
        } catch (R) {
          c(R);
        }
      });
    }
    try {
      const v = r.create(l, s);
      h(null, n(v, a, s));
    } catch (v) {
      h(v);
    }
  }
  return Tt.create = r.create, Tt.toCanvas = f.bind(null, t.render), Tt.toDataURL = f.bind(null, t.renderToDataURL), Tt.toString = f.bind(null, function(n, a, l) {
    return i.render(n, l);
  }), Tt;
}
var Po = $o();
const qo = /* @__PURE__ */ Aa(Po);
function Ko(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Qn = { exports: {} }, Vn = {}, vi;
function ct() {
  return vi || (vi = 1, function(e) {
    var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function t(n, a) {
      return Object.prototype.hasOwnProperty.call(n, a);
    }
    e.assign = function(n) {
      for (var a = Array.prototype.slice.call(arguments, 1); a.length; ) {
        var l = a.shift();
        if (l) {
          if (typeof l != "object")
            throw new TypeError(l + "must be non-object");
          for (var s in l)
            t(l, s) && (n[s] = l[s]);
        }
      }
      return n;
    }, e.shrinkBuf = function(n, a) {
      return n.length === a ? n : n.subarray ? n.subarray(0, a) : (n.length = a, n);
    };
    var i = {
      arraySet: function(n, a, l, s, h) {
        if (a.subarray && n.subarray) {
          n.set(a.subarray(l, l + s), h);
          return;
        }
        for (var u = 0; u < s; u++)
          n[h + u] = a[l + u];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        var a, l, s, h, u, d;
        for (s = 0, a = 0, l = n.length; a < l; a++)
          s += n[a].length;
        for (d = new Uint8Array(s), h = 0, a = 0, l = n.length; a < l; a++)
          u = n[a], d.set(u, h), h += u.length;
        return d;
      }
    }, f = {
      arraySet: function(n, a, l, s, h) {
        for (var u = 0; u < s; u++)
          n[h + u] = a[l + u];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        return [].concat.apply([], n);
      }
    };
    e.setTyped = function(n) {
      n ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, f));
    }, e.setTyped(r);
  }(Vn)), Vn;
}
var zt = {}, qe = {}, dt = {}, wi;
function Yo() {
  if (wi) return dt;
  wi = 1;
  var e = ct(), r = 4, t = 0, i = 1, f = 2;
  function n(p) {
    for (var F = p.length; --F >= 0; )
      p[F] = 0;
  }
  var a = 0, l = 1, s = 2, h = 3, u = 258, d = 29, g = 256, v = g + 1 + d, c = 30, R = 19, S = 2 * v + 1, b = 15, x = 16, m = 7, k = 256, L = 16, z = 17, E = 18, T = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), I = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), D = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], O = 512, N = new Array((v + 2) * 2);
  n(N);
  var U = new Array(c * 2);
  n(U);
  var X = new Array(O);
  n(X);
  var Y = new Array(u - h + 1);
  n(Y);
  var q = new Array(d);
  n(q);
  var V = new Array(c);
  n(V);
  function ne(p, F, P, j, A) {
    this.static_tree = p, this.extra_bits = F, this.extra_base = P, this.elems = j, this.max_length = A, this.has_stree = p && p.length;
  }
  var ve, be, de;
  function he(p, F) {
    this.dyn_tree = p, this.max_code = 0, this.stat_desc = F;
  }
  function ge(p) {
    return p < 256 ? X[p] : X[256 + (p >>> 7)];
  }
  function ue(p, F) {
    p.pending_buf[p.pending++] = F & 255, p.pending_buf[p.pending++] = F >>> 8 & 255;
  }
  function re(p, F, P) {
    p.bi_valid > x - P ? (p.bi_buf |= F << p.bi_valid & 65535, ue(p, p.bi_buf), p.bi_buf = F >> x - p.bi_valid, p.bi_valid += P - x) : (p.bi_buf |= F << p.bi_valid & 65535, p.bi_valid += P);
  }
  function ie(p, F, P) {
    re(
      p,
      P[F * 2],
      P[F * 2 + 1]
      /*.Len*/
    );
  }
  function G(p, F) {
    var P = 0;
    do
      P |= p & 1, p >>>= 1, P <<= 1;
    while (--F > 0);
    return P >>> 1;
  }
  function W(p) {
    p.bi_valid === 16 ? (ue(p, p.bi_buf), p.bi_buf = 0, p.bi_valid = 0) : p.bi_valid >= 8 && (p.pending_buf[p.pending++] = p.bi_buf & 255, p.bi_buf >>= 8, p.bi_valid -= 8);
  }
  function Ee(p, F) {
    var P = F.dyn_tree, j = F.max_code, A = F.stat_desc.static_tree, H = F.stat_desc.has_stree, _ = F.stat_desc.extra_bits, $ = F.stat_desc.extra_base, ee = F.stat_desc.max_length, o, M, Z, w, y, B, J = 0;
    for (w = 0; w <= b; w++)
      p.bl_count[w] = 0;
    for (P[p.heap[p.heap_max] * 2 + 1] = 0, o = p.heap_max + 1; o < S; o++)
      M = p.heap[o], w = P[P[M * 2 + 1] * 2 + 1] + 1, w > ee && (w = ee, J++), P[M * 2 + 1] = w, !(M > j) && (p.bl_count[w]++, y = 0, M >= $ && (y = _[M - $]), B = P[M * 2], p.opt_len += B * (w + y), H && (p.static_len += B * (A[M * 2 + 1] + y)));
    if (J !== 0) {
      do {
        for (w = ee - 1; p.bl_count[w] === 0; )
          w--;
        p.bl_count[w]--, p.bl_count[w + 1] += 2, p.bl_count[ee]--, J -= 2;
      } while (J > 0);
      for (w = ee; w !== 0; w--)
        for (M = p.bl_count[w]; M !== 0; )
          Z = p.heap[--o], !(Z > j) && (P[Z * 2 + 1] !== w && (p.opt_len += (w - P[Z * 2 + 1]) * P[Z * 2], P[Z * 2 + 1] = w), M--);
    }
  }
  function ze(p, F, P) {
    var j = new Array(b + 1), A = 0, H, _;
    for (H = 1; H <= b; H++)
      j[H] = A = A + P[H - 1] << 1;
    for (_ = 0; _ <= F; _++) {
      var $ = p[_ * 2 + 1];
      $ !== 0 && (p[_ * 2] = G(j[$]++, $));
    }
  }
  function te() {
    var p, F, P, j, A, H = new Array(b + 1);
    for (P = 0, j = 0; j < d - 1; j++)
      for (q[j] = P, p = 0; p < 1 << T[j]; p++)
        Y[P++] = j;
    for (Y[P - 1] = j, A = 0, j = 0; j < 16; j++)
      for (V[j] = A, p = 0; p < 1 << I[j]; p++)
        X[A++] = j;
    for (A >>= 7; j < c; j++)
      for (V[j] = A << 7, p = 0; p < 1 << I[j] - 7; p++)
        X[256 + A++] = j;
    for (F = 0; F <= b; F++)
      H[F] = 0;
    for (p = 0; p <= 143; )
      N[p * 2 + 1] = 8, p++, H[8]++;
    for (; p <= 255; )
      N[p * 2 + 1] = 9, p++, H[9]++;
    for (; p <= 279; )
      N[p * 2 + 1] = 7, p++, H[7]++;
    for (; p <= 287; )
      N[p * 2 + 1] = 8, p++, H[8]++;
    for (ze(N, v + 1, H), p = 0; p < c; p++)
      U[p * 2 + 1] = 5, U[p * 2] = G(p, 5);
    ve = new ne(N, T, g + 1, v, b), be = new ne(U, I, 0, c, b), de = new ne(new Array(0), D, 0, R, m);
  }
  function pe(p) {
    var F;
    for (F = 0; F < v; F++)
      p.dyn_ltree[F * 2] = 0;
    for (F = 0; F < c; F++)
      p.dyn_dtree[F * 2] = 0;
    for (F = 0; F < R; F++)
      p.bl_tree[F * 2] = 0;
    p.dyn_ltree[k * 2] = 1, p.opt_len = p.static_len = 0, p.last_lit = p.matches = 0;
  }
  function Ne(p) {
    p.bi_valid > 8 ? ue(p, p.bi_buf) : p.bi_valid > 0 && (p.pending_buf[p.pending++] = p.bi_buf), p.bi_buf = 0, p.bi_valid = 0;
  }
  function Ie(p, F, P, j) {
    Ne(p), ue(p, P), ue(p, ~P), e.arraySet(p.pending_buf, p.window, F, P, p.pending), p.pending += P;
  }
  function ye(p, F, P, j) {
    var A = F * 2, H = P * 2;
    return p[A] < p[H] || p[A] === p[H] && j[F] <= j[P];
  }
  function ce(p, F, P) {
    for (var j = p.heap[P], A = P << 1; A <= p.heap_len && (A < p.heap_len && ye(F, p.heap[A + 1], p.heap[A], p.depth) && A++, !ye(F, j, p.heap[A], p.depth)); )
      p.heap[P] = p.heap[A], P = A, A <<= 1;
    p.heap[P] = j;
  }
  function ae(p, F, P) {
    var j, A, H = 0, _, $;
    if (p.last_lit !== 0)
      do
        j = p.pending_buf[p.d_buf + H * 2] << 8 | p.pending_buf[p.d_buf + H * 2 + 1], A = p.pending_buf[p.l_buf + H], H++, j === 0 ? ie(p, A, F) : (_ = Y[A], ie(p, _ + g + 1, F), $ = T[_], $ !== 0 && (A -= q[_], re(p, A, $)), j--, _ = ge(j), ie(p, _, P), $ = I[_], $ !== 0 && (j -= V[_], re(p, j, $)));
      while (H < p.last_lit);
    ie(p, k, F);
  }
  function Ze(p, F) {
    var P = F.dyn_tree, j = F.stat_desc.static_tree, A = F.stat_desc.has_stree, H = F.stat_desc.elems, _, $, ee = -1, o;
    for (p.heap_len = 0, p.heap_max = S, _ = 0; _ < H; _++)
      P[_ * 2] !== 0 ? (p.heap[++p.heap_len] = ee = _, p.depth[_] = 0) : P[_ * 2 + 1] = 0;
    for (; p.heap_len < 2; )
      o = p.heap[++p.heap_len] = ee < 2 ? ++ee : 0, P[o * 2] = 1, p.depth[o] = 0, p.opt_len--, A && (p.static_len -= j[o * 2 + 1]);
    for (F.max_code = ee, _ = p.heap_len >> 1; _ >= 1; _--)
      ce(p, P, _);
    o = H;
    do
      _ = p.heap[
        1
        /*SMALLEST*/
      ], p.heap[
        1
        /*SMALLEST*/
      ] = p.heap[p.heap_len--], ce(
        p,
        P,
        1
        /*SMALLEST*/
      ), $ = p.heap[
        1
        /*SMALLEST*/
      ], p.heap[--p.heap_max] = _, p.heap[--p.heap_max] = $, P[o * 2] = P[_ * 2] + P[$ * 2], p.depth[o] = (p.depth[_] >= p.depth[$] ? p.depth[_] : p.depth[$]) + 1, P[_ * 2 + 1] = P[$ * 2 + 1] = o, p.heap[
        1
        /*SMALLEST*/
      ] = o++, ce(
        p,
        P,
        1
        /*SMALLEST*/
      );
    while (p.heap_len >= 2);
    p.heap[--p.heap_max] = p.heap[
      1
      /*SMALLEST*/
    ], Ee(p, F), ze(P, ee, p.bl_count);
  }
  function yt(p, F, P) {
    var j, A = -1, H, _ = F[0 * 2 + 1], $ = 0, ee = 7, o = 4;
    for (_ === 0 && (ee = 138, o = 3), F[(P + 1) * 2 + 1] = 65535, j = 0; j <= P; j++)
      H = _, _ = F[(j + 1) * 2 + 1], !(++$ < ee && H === _) && ($ < o ? p.bl_tree[H * 2] += $ : H !== 0 ? (H !== A && p.bl_tree[H * 2]++, p.bl_tree[L * 2]++) : $ <= 10 ? p.bl_tree[z * 2]++ : p.bl_tree[E * 2]++, $ = 0, A = H, _ === 0 ? (ee = 138, o = 3) : H === _ ? (ee = 6, o = 3) : (ee = 7, o = 4));
  }
  function rt(p, F, P) {
    var j, A = -1, H, _ = F[0 * 2 + 1], $ = 0, ee = 7, o = 4;
    for (_ === 0 && (ee = 138, o = 3), j = 0; j <= P; j++)
      if (H = _, _ = F[(j + 1) * 2 + 1], !(++$ < ee && H === _)) {
        if ($ < o)
          do
            ie(p, H, p.bl_tree);
          while (--$ !== 0);
        else H !== 0 ? (H !== A && (ie(p, H, p.bl_tree), $--), ie(p, L, p.bl_tree), re(p, $ - 3, 2)) : $ <= 10 ? (ie(p, z, p.bl_tree), re(p, $ - 3, 3)) : (ie(p, E, p.bl_tree), re(p, $ - 11, 7));
        $ = 0, A = H, _ === 0 ? (ee = 138, o = 3) : H === _ ? (ee = 6, o = 3) : (ee = 7, o = 4);
      }
  }
  function Oe(p) {
    var F;
    for (yt(p, p.dyn_ltree, p.l_desc.max_code), yt(p, p.dyn_dtree, p.d_desc.max_code), Ze(p, p.bl_desc), F = R - 1; F >= 3 && p.bl_tree[C[F] * 2 + 1] === 0; F--)
      ;
    return p.opt_len += 3 * (F + 1) + 5 + 5 + 4, F;
  }
  function At(p, F, P, j) {
    var A;
    for (re(p, F - 257, 5), re(p, P - 1, 5), re(p, j - 4, 4), A = 0; A < j; A++)
      re(p, p.bl_tree[C[A] * 2 + 1], 3);
    rt(p, p.dyn_ltree, F - 1), rt(p, p.dyn_dtree, P - 1);
  }
  function it(p) {
    var F = 4093624447, P;
    for (P = 0; P <= 31; P++, F >>>= 1)
      if (F & 1 && p.dyn_ltree[P * 2] !== 0)
        return t;
    if (p.dyn_ltree[9 * 2] !== 0 || p.dyn_ltree[10 * 2] !== 0 || p.dyn_ltree[13 * 2] !== 0)
      return i;
    for (P = 32; P < g; P++)
      if (p.dyn_ltree[P * 2] !== 0)
        return i;
    return t;
  }
  var Pe = !1;
  function St(p) {
    Pe || (te(), Pe = !0), p.l_desc = new he(p.dyn_ltree, ve), p.d_desc = new he(p.dyn_dtree, be), p.bl_desc = new he(p.bl_tree, de), p.bi_buf = 0, p.bi_valid = 0, pe(p);
  }
  function at(p, F, P, j) {
    re(p, (a << 1) + (j ? 1 : 0), 3), Ie(p, F, P);
  }
  function Re(p) {
    re(p, l << 1, 3), ie(p, k, N), W(p);
  }
  function Ke(p, F, P, j) {
    var A, H, _ = 0;
    p.level > 0 ? (p.strm.data_type === f && (p.strm.data_type = it(p)), Ze(p, p.l_desc), Ze(p, p.d_desc), _ = Oe(p), A = p.opt_len + 3 + 7 >>> 3, H = p.static_len + 3 + 7 >>> 3, H <= A && (A = H)) : A = H = P + 5, P + 4 <= A && F !== -1 ? at(p, F, P, j) : p.strategy === r || H === A ? (re(p, (l << 1) + (j ? 1 : 0), 3), ae(p, N, U)) : (re(p, (s << 1) + (j ? 1 : 0), 3), At(p, p.l_desc.max_code + 1, p.d_desc.max_code + 1, _ + 1), ae(p, p.dyn_ltree, p.dyn_dtree)), pe(p), j && Ne(p);
  }
  function Rt(p, F, P) {
    return p.pending_buf[p.d_buf + p.last_lit * 2] = F >>> 8 & 255, p.pending_buf[p.d_buf + p.last_lit * 2 + 1] = F & 255, p.pending_buf[p.l_buf + p.last_lit] = P & 255, p.last_lit++, F === 0 ? p.dyn_ltree[P * 2]++ : (p.matches++, F--, p.dyn_ltree[(Y[P] + g + 1) * 2]++, p.dyn_dtree[ge(F) * 2]++), p.last_lit === p.lit_bufsize - 1;
  }
  return dt._tr_init = St, dt._tr_stored_block = at, dt._tr_flush_block = Ke, dt._tr_tally = Rt, dt._tr_align = Re, dt;
}
var jn, bi;
function Ca() {
  if (bi) return jn;
  bi = 1;
  function e(r, t, i, f) {
    for (var n = r & 65535 | 0, a = r >>> 16 & 65535 | 0, l = 0; i !== 0; ) {
      l = i > 2e3 ? 2e3 : i, i -= l;
      do
        n = n + t[f++] | 0, a = a + n | 0;
      while (--l);
      n %= 65521, a %= 65521;
    }
    return n | a << 16 | 0;
  }
  return jn = e, jn;
}
var Xn, pi;
function Ia() {
  if (pi) return Xn;
  pi = 1;
  function e() {
    for (var i, f = [], n = 0; n < 256; n++) {
      i = n;
      for (var a = 0; a < 8; a++)
        i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
      f[n] = i;
    }
    return f;
  }
  var r = e();
  function t(i, f, n, a) {
    var l = r, s = a + n;
    i ^= -1;
    for (var h = a; h < s; h++)
      i = i >>> 8 ^ l[(i ^ f[h]) & 255];
    return i ^ -1;
  }
  return Xn = t, Xn;
}
var Jn, xi;
function Dr() {
  return xi || (xi = 1, Jn = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), Jn;
}
var Ei;
function Qo() {
  if (Ei) return qe;
  Ei = 1;
  var e = ct(), r = Yo(), t = Ca(), i = Ia(), f = Dr(), n = 0, a = 1, l = 3, s = 4, h = 5, u = 0, d = 1, g = -2, v = -3, c = -5, R = -1, S = 1, b = 2, x = 3, m = 4, k = 0, L = 2, z = 8, E = 9, T = 15, I = 8, D = 29, C = 256, O = C + 1 + D, N = 30, U = 19, X = 2 * O + 1, Y = 15, q = 3, V = 258, ne = V + q + 1, ve = 32, be = 42, de = 69, he = 73, ge = 91, ue = 103, re = 113, ie = 666, G = 1, W = 2, Ee = 3, ze = 4, te = 3;
  function pe(o, M) {
    return o.msg = f[M], M;
  }
  function Ne(o) {
    return (o << 1) - (o > 4 ? 9 : 0);
  }
  function Ie(o) {
    for (var M = o.length; --M >= 0; )
      o[M] = 0;
  }
  function ye(o) {
    var M = o.state, Z = M.pending;
    Z > o.avail_out && (Z = o.avail_out), Z !== 0 && (e.arraySet(o.output, M.pending_buf, M.pending_out, Z, o.next_out), o.next_out += Z, M.pending_out += Z, o.total_out += Z, o.avail_out -= Z, M.pending -= Z, M.pending === 0 && (M.pending_out = 0));
  }
  function ce(o, M) {
    r._tr_flush_block(o, o.block_start >= 0 ? o.block_start : -1, o.strstart - o.block_start, M), o.block_start = o.strstart, ye(o.strm);
  }
  function ae(o, M) {
    o.pending_buf[o.pending++] = M;
  }
  function Ze(o, M) {
    o.pending_buf[o.pending++] = M >>> 8 & 255, o.pending_buf[o.pending++] = M & 255;
  }
  function yt(o, M, Z, w) {
    var y = o.avail_in;
    return y > w && (y = w), y === 0 ? 0 : (o.avail_in -= y, e.arraySet(M, o.input, o.next_in, y, Z), o.state.wrap === 1 ? o.adler = t(o.adler, M, y, Z) : o.state.wrap === 2 && (o.adler = i(o.adler, M, y, Z)), o.next_in += y, o.total_in += y, y);
  }
  function rt(o, M) {
    var Z = o.max_chain_length, w = o.strstart, y, B, J = o.prev_length, K = o.nice_match, Q = o.strstart > o.w_size - ne ? o.strstart - (o.w_size - ne) : 0, fe = o.window, We = o.w_mask, we = o.prev, le = o.strstart + V, ke = fe[w + J - 1], Te = fe[w + J];
    o.prev_length >= o.good_match && (Z >>= 2), K > o.lookahead && (K = o.lookahead);
    do
      if (y = M, !(fe[y + J] !== Te || fe[y + J - 1] !== ke || fe[y] !== fe[w] || fe[++y] !== fe[w + 1])) {
        w += 2, y++;
        do
          ;
        while (fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && w < le);
        if (B = V - (le - w), w = le - V, B > J) {
          if (o.match_start = M, J = B, B >= K)
            break;
          ke = fe[w + J - 1], Te = fe[w + J];
        }
      }
    while ((M = we[M & We]) > Q && --Z !== 0);
    return J <= o.lookahead ? J : o.lookahead;
  }
  function Oe(o) {
    var M = o.w_size, Z, w, y, B, J;
    do {
      if (B = o.window_size - o.lookahead - o.strstart, o.strstart >= M + (M - ne)) {
        e.arraySet(o.window, o.window, M, M, 0), o.match_start -= M, o.strstart -= M, o.block_start -= M, w = o.hash_size, Z = w;
        do
          y = o.head[--Z], o.head[Z] = y >= M ? y - M : 0;
        while (--w);
        w = M, Z = w;
        do
          y = o.prev[--Z], o.prev[Z] = y >= M ? y - M : 0;
        while (--w);
        B += M;
      }
      if (o.strm.avail_in === 0)
        break;
      if (w = yt(o.strm, o.window, o.strstart + o.lookahead, B), o.lookahead += w, o.lookahead + o.insert >= q)
        for (J = o.strstart - o.insert, o.ins_h = o.window[J], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[J + 1]) & o.hash_mask; o.insert && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[J + q - 1]) & o.hash_mask, o.prev[J & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = J, J++, o.insert--, !(o.lookahead + o.insert < q)); )
          ;
    } while (o.lookahead < ne && o.strm.avail_in !== 0);
  }
  function At(o, M) {
    var Z = 65535;
    for (Z > o.pending_buf_size - 5 && (Z = o.pending_buf_size - 5); ; ) {
      if (o.lookahead <= 1) {
        if (Oe(o), o.lookahead === 0 && M === n)
          return G;
        if (o.lookahead === 0)
          break;
      }
      o.strstart += o.lookahead, o.lookahead = 0;
      var w = o.block_start + Z;
      if ((o.strstart === 0 || o.strstart >= w) && (o.lookahead = o.strstart - w, o.strstart = w, ce(o, !1), o.strm.avail_out === 0) || o.strstart - o.block_start >= o.w_size - ne && (ce(o, !1), o.strm.avail_out === 0))
        return G;
    }
    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : (o.strstart > o.block_start && (ce(o, !1), o.strm.avail_out === 0), G);
  }
  function it(o, M) {
    for (var Z, w; ; ) {
      if (o.lookahead < ne) {
        if (Oe(o), o.lookahead < ne && M === n)
          return G;
        if (o.lookahead === 0)
          break;
      }
      if (Z = 0, o.lookahead >= q && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), Z !== 0 && o.strstart - Z <= o.w_size - ne && (o.match_length = rt(o, Z)), o.match_length >= q)
        if (w = r._tr_tally(o, o.strstart - o.match_start, o.match_length - q), o.lookahead -= o.match_length, o.match_length <= o.max_lazy_match && o.lookahead >= q) {
          o.match_length--;
          do
            o.strstart++, o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart;
          while (--o.match_length !== 0);
          o.strstart++;
        } else
          o.strstart += o.match_length, o.match_length = 0, o.ins_h = o.window[o.strstart], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + 1]) & o.hash_mask;
      else
        w = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++;
      if (w && (ce(o, !1), o.strm.avail_out === 0))
        return G;
    }
    return o.insert = o.strstart < q - 1 ? o.strstart : q - 1, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;
  }
  function Pe(o, M) {
    for (var Z, w, y; ; ) {
      if (o.lookahead < ne) {
        if (Oe(o), o.lookahead < ne && M === n)
          return G;
        if (o.lookahead === 0)
          break;
      }
      if (Z = 0, o.lookahead >= q && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), o.prev_length = o.match_length, o.prev_match = o.match_start, o.match_length = q - 1, Z !== 0 && o.prev_length < o.max_lazy_match && o.strstart - Z <= o.w_size - ne && (o.match_length = rt(o, Z), o.match_length <= 5 && (o.strategy === S || o.match_length === q && o.strstart - o.match_start > 4096) && (o.match_length = q - 1)), o.prev_length >= q && o.match_length <= o.prev_length) {
        y = o.strstart + o.lookahead - q, w = r._tr_tally(o, o.strstart - 1 - o.prev_match, o.prev_length - q), o.lookahead -= o.prev_length - 1, o.prev_length -= 2;
        do
          ++o.strstart <= y && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart);
        while (--o.prev_length !== 0);
        if (o.match_available = 0, o.match_length = q - 1, o.strstart++, w && (ce(o, !1), o.strm.avail_out === 0))
          return G;
      } else if (o.match_available) {
        if (w = r._tr_tally(o, 0, o.window[o.strstart - 1]), w && ce(o, !1), o.strstart++, o.lookahead--, o.strm.avail_out === 0)
          return G;
      } else
        o.match_available = 1, o.strstart++, o.lookahead--;
    }
    return o.match_available && (w = r._tr_tally(o, 0, o.window[o.strstart - 1]), o.match_available = 0), o.insert = o.strstart < q - 1 ? o.strstart : q - 1, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;
  }
  function St(o, M) {
    for (var Z, w, y, B, J = o.window; ; ) {
      if (o.lookahead <= V) {
        if (Oe(o), o.lookahead <= V && M === n)
          return G;
        if (o.lookahead === 0)
          break;
      }
      if (o.match_length = 0, o.lookahead >= q && o.strstart > 0 && (y = o.strstart - 1, w = J[y], w === J[++y] && w === J[++y] && w === J[++y])) {
        B = o.strstart + V;
        do
          ;
        while (w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && y < B);
        o.match_length = V - (B - y), o.match_length > o.lookahead && (o.match_length = o.lookahead);
      }
      if (o.match_length >= q ? (Z = r._tr_tally(o, 1, o.match_length - q), o.lookahead -= o.match_length, o.strstart += o.match_length, o.match_length = 0) : (Z = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++), Z && (ce(o, !1), o.strm.avail_out === 0))
        return G;
    }
    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;
  }
  function at(o, M) {
    for (var Z; ; ) {
      if (o.lookahead === 0 && (Oe(o), o.lookahead === 0)) {
        if (M === n)
          return G;
        break;
      }
      if (o.match_length = 0, Z = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++, Z && (ce(o, !1), o.strm.avail_out === 0))
        return G;
    }
    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;
  }
  function Re(o, M, Z, w, y) {
    this.good_length = o, this.max_lazy = M, this.nice_length = Z, this.max_chain = w, this.func = y;
  }
  var Ke;
  Ke = [
    /*      good lazy nice chain */
    new Re(0, 0, 0, 0, At),
    /* 0 store only */
    new Re(4, 4, 8, 4, it),
    /* 1 max speed, no lazy matches */
    new Re(4, 5, 16, 8, it),
    /* 2 */
    new Re(4, 6, 32, 32, it),
    /* 3 */
    new Re(4, 4, 16, 16, Pe),
    /* 4 lazy matches */
    new Re(8, 16, 32, 32, Pe),
    /* 5 */
    new Re(8, 16, 128, 128, Pe),
    /* 6 */
    new Re(8, 32, 128, 256, Pe),
    /* 7 */
    new Re(32, 128, 258, 1024, Pe),
    /* 8 */
    new Re(32, 258, 258, 4096, Pe)
    /* 9 max compression */
  ];
  function Rt(o) {
    o.window_size = 2 * o.w_size, Ie(o.head), o.max_lazy_match = Ke[o.level].max_lazy, o.good_match = Ke[o.level].good_length, o.nice_match = Ke[o.level].nice_length, o.max_chain_length = Ke[o.level].max_chain, o.strstart = 0, o.block_start = 0, o.lookahead = 0, o.insert = 0, o.match_length = o.prev_length = q - 1, o.match_available = 0, o.ins_h = 0;
  }
  function p() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = z, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(X * 2), this.dyn_dtree = new e.Buf16((2 * N + 1) * 2), this.bl_tree = new e.Buf16((2 * U + 1) * 2), Ie(this.dyn_ltree), Ie(this.dyn_dtree), Ie(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(Y + 1), this.heap = new e.Buf16(2 * O + 1), Ie(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * O + 1), Ie(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function F(o) {
    var M;
    return !o || !o.state ? pe(o, g) : (o.total_in = o.total_out = 0, o.data_type = L, M = o.state, M.pending = 0, M.pending_out = 0, M.wrap < 0 && (M.wrap = -M.wrap), M.status = M.wrap ? be : re, o.adler = M.wrap === 2 ? 0 : 1, M.last_flush = n, r._tr_init(M), u);
  }
  function P(o) {
    var M = F(o);
    return M === u && Rt(o.state), M;
  }
  function j(o, M) {
    return !o || !o.state || o.state.wrap !== 2 ? g : (o.state.gzhead = M, u);
  }
  function A(o, M, Z, w, y, B) {
    if (!o)
      return g;
    var J = 1;
    if (M === R && (M = 6), w < 0 ? (J = 0, w = -w) : w > 15 && (J = 2, w -= 16), y < 1 || y > E || Z !== z || w < 8 || w > 15 || M < 0 || M > 9 || B < 0 || B > m)
      return pe(o, g);
    w === 8 && (w = 9);
    var K = new p();
    return o.state = K, K.strm = o, K.wrap = J, K.gzhead = null, K.w_bits = w, K.w_size = 1 << K.w_bits, K.w_mask = K.w_size - 1, K.hash_bits = y + 7, K.hash_size = 1 << K.hash_bits, K.hash_mask = K.hash_size - 1, K.hash_shift = ~~((K.hash_bits + q - 1) / q), K.window = new e.Buf8(K.w_size * 2), K.head = new e.Buf16(K.hash_size), K.prev = new e.Buf16(K.w_size), K.lit_bufsize = 1 << y + 6, K.pending_buf_size = K.lit_bufsize * 4, K.pending_buf = new e.Buf8(K.pending_buf_size), K.d_buf = 1 * K.lit_bufsize, K.l_buf = 3 * K.lit_bufsize, K.level = M, K.strategy = B, K.method = Z, P(o);
  }
  function H(o, M) {
    return A(o, M, z, T, I, k);
  }
  function _(o, M) {
    var Z, w, y, B;
    if (!o || !o.state || M > h || M < 0)
      return o ? pe(o, g) : g;
    if (w = o.state, !o.output || !o.input && o.avail_in !== 0 || w.status === ie && M !== s)
      return pe(o, o.avail_out === 0 ? c : g);
    if (w.strm = o, Z = w.last_flush, w.last_flush = M, w.status === be)
      if (w.wrap === 2)
        o.adler = 0, ae(w, 31), ae(w, 139), ae(w, 8), w.gzhead ? (ae(
          w,
          (w.gzhead.text ? 1 : 0) + (w.gzhead.hcrc ? 2 : 0) + (w.gzhead.extra ? 4 : 0) + (w.gzhead.name ? 8 : 0) + (w.gzhead.comment ? 16 : 0)
        ), ae(w, w.gzhead.time & 255), ae(w, w.gzhead.time >> 8 & 255), ae(w, w.gzhead.time >> 16 & 255), ae(w, w.gzhead.time >> 24 & 255), ae(w, w.level === 9 ? 2 : w.strategy >= b || w.level < 2 ? 4 : 0), ae(w, w.gzhead.os & 255), w.gzhead.extra && w.gzhead.extra.length && (ae(w, w.gzhead.extra.length & 255), ae(w, w.gzhead.extra.length >> 8 & 255)), w.gzhead.hcrc && (o.adler = i(o.adler, w.pending_buf, w.pending, 0)), w.gzindex = 0, w.status = de) : (ae(w, 0), ae(w, 0), ae(w, 0), ae(w, 0), ae(w, 0), ae(w, w.level === 9 ? 2 : w.strategy >= b || w.level < 2 ? 4 : 0), ae(w, te), w.status = re);
      else {
        var J = z + (w.w_bits - 8 << 4) << 8, K = -1;
        w.strategy >= b || w.level < 2 ? K = 0 : w.level < 6 ? K = 1 : w.level === 6 ? K = 2 : K = 3, J |= K << 6, w.strstart !== 0 && (J |= ve), J += 31 - J % 31, w.status = re, Ze(w, J), w.strstart !== 0 && (Ze(w, o.adler >>> 16), Ze(w, o.adler & 65535)), o.adler = 1;
      }
    if (w.status === de)
      if (w.gzhead.extra) {
        for (y = w.pending; w.gzindex < (w.gzhead.extra.length & 65535) && !(w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)); )
          ae(w, w.gzhead.extra[w.gzindex] & 255), w.gzindex++;
        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), w.gzindex === w.gzhead.extra.length && (w.gzindex = 0, w.status = he);
      } else
        w.status = he;
    if (w.status === he)
      if (w.gzhead.name) {
        y = w.pending;
        do {
          if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)) {
            B = 1;
            break;
          }
          w.gzindex < w.gzhead.name.length ? B = w.gzhead.name.charCodeAt(w.gzindex++) & 255 : B = 0, ae(w, B);
        } while (B !== 0);
        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), B === 0 && (w.gzindex = 0, w.status = ge);
      } else
        w.status = ge;
    if (w.status === ge)
      if (w.gzhead.comment) {
        y = w.pending;
        do {
          if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)) {
            B = 1;
            break;
          }
          w.gzindex < w.gzhead.comment.length ? B = w.gzhead.comment.charCodeAt(w.gzindex++) & 255 : B = 0, ae(w, B);
        } while (B !== 0);
        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), B === 0 && (w.status = ue);
      } else
        w.status = ue;
    if (w.status === ue && (w.gzhead.hcrc ? (w.pending + 2 > w.pending_buf_size && ye(o), w.pending + 2 <= w.pending_buf_size && (ae(w, o.adler & 255), ae(w, o.adler >> 8 & 255), o.adler = 0, w.status = re)) : w.status = re), w.pending !== 0) {
      if (ye(o), o.avail_out === 0)
        return w.last_flush = -1, u;
    } else if (o.avail_in === 0 && Ne(M) <= Ne(Z) && M !== s)
      return pe(o, c);
    if (w.status === ie && o.avail_in !== 0)
      return pe(o, c);
    if (o.avail_in !== 0 || w.lookahead !== 0 || M !== n && w.status !== ie) {
      var Q = w.strategy === b ? at(w, M) : w.strategy === x ? St(w, M) : Ke[w.level].func(w, M);
      if ((Q === Ee || Q === ze) && (w.status = ie), Q === G || Q === Ee)
        return o.avail_out === 0 && (w.last_flush = -1), u;
      if (Q === W && (M === a ? r._tr_align(w) : M !== h && (r._tr_stored_block(w, 0, 0, !1), M === l && (Ie(w.head), w.lookahead === 0 && (w.strstart = 0, w.block_start = 0, w.insert = 0))), ye(o), o.avail_out === 0))
        return w.last_flush = -1, u;
    }
    return M !== s ? u : w.wrap <= 0 ? d : (w.wrap === 2 ? (ae(w, o.adler & 255), ae(w, o.adler >> 8 & 255), ae(w, o.adler >> 16 & 255), ae(w, o.adler >> 24 & 255), ae(w, o.total_in & 255), ae(w, o.total_in >> 8 & 255), ae(w, o.total_in >> 16 & 255), ae(w, o.total_in >> 24 & 255)) : (Ze(w, o.adler >>> 16), Ze(w, o.adler & 65535)), ye(o), w.wrap > 0 && (w.wrap = -w.wrap), w.pending !== 0 ? u : d);
  }
  function $(o) {
    var M;
    return !o || !o.state ? g : (M = o.state.status, M !== be && M !== de && M !== he && M !== ge && M !== ue && M !== re && M !== ie ? pe(o, g) : (o.state = null, M === re ? pe(o, v) : u));
  }
  function ee(o, M) {
    var Z = M.length, w, y, B, J, K, Q, fe, We;
    if (!o || !o.state || (w = o.state, J = w.wrap, J === 2 || J === 1 && w.status !== be || w.lookahead))
      return g;
    for (J === 1 && (o.adler = t(o.adler, M, Z, 0)), w.wrap = 0, Z >= w.w_size && (J === 0 && (Ie(w.head), w.strstart = 0, w.block_start = 0, w.insert = 0), We = new e.Buf8(w.w_size), e.arraySet(We, M, Z - w.w_size, w.w_size, 0), M = We, Z = w.w_size), K = o.avail_in, Q = o.next_in, fe = o.input, o.avail_in = Z, o.next_in = 0, o.input = M, Oe(w); w.lookahead >= q; ) {
      y = w.strstart, B = w.lookahead - (q - 1);
      do
        w.ins_h = (w.ins_h << w.hash_shift ^ w.window[y + q - 1]) & w.hash_mask, w.prev[y & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = y, y++;
      while (--B);
      w.strstart = y, w.lookahead = q - 1, Oe(w);
    }
    return w.strstart += w.lookahead, w.block_start = w.strstart, w.insert = w.lookahead, w.lookahead = 0, w.match_length = w.prev_length = q - 1, w.match_available = 0, o.next_in = Q, o.input = fe, o.avail_in = K, w.wrap = J, u;
  }
  return qe.deflateInit = H, qe.deflateInit2 = A, qe.deflateReset = P, qe.deflateResetKeep = F, qe.deflateSetHeader = j, qe.deflate = _, qe.deflateEnd = $, qe.deflateSetDictionary = ee, qe.deflateInfo = "pako deflate (from Nodeca project)", qe;
}
var _t = {}, ki;
function Da() {
  if (ki) return _t;
  ki = 1;
  var e = ct(), r = !0, t = !0;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch {
    r = !1;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    t = !1;
  }
  for (var i = new e.Buf8(256), f = 0; f < 256; f++)
    i[f] = f >= 252 ? 6 : f >= 248 ? 5 : f >= 240 ? 4 : f >= 224 ? 3 : f >= 192 ? 2 : 1;
  i[254] = i[254] = 1, _t.string2buf = function(a) {
    var l, s, h, u, d, g = a.length, v = 0;
    for (u = 0; u < g; u++)
      s = a.charCodeAt(u), (s & 64512) === 55296 && u + 1 < g && (h = a.charCodeAt(u + 1), (h & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (h - 56320), u++)), v += s < 128 ? 1 : s < 2048 ? 2 : s < 65536 ? 3 : 4;
    for (l = new e.Buf8(v), d = 0, u = 0; d < v; u++)
      s = a.charCodeAt(u), (s & 64512) === 55296 && u + 1 < g && (h = a.charCodeAt(u + 1), (h & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (h - 56320), u++)), s < 128 ? l[d++] = s : s < 2048 ? (l[d++] = 192 | s >>> 6, l[d++] = 128 | s & 63) : s < 65536 ? (l[d++] = 224 | s >>> 12, l[d++] = 128 | s >>> 6 & 63, l[d++] = 128 | s & 63) : (l[d++] = 240 | s >>> 18, l[d++] = 128 | s >>> 12 & 63, l[d++] = 128 | s >>> 6 & 63, l[d++] = 128 | s & 63);
    return l;
  };
  function n(a, l) {
    if (l < 65534 && (a.subarray && t || !a.subarray && r))
      return String.fromCharCode.apply(null, e.shrinkBuf(a, l));
    for (var s = "", h = 0; h < l; h++)
      s += String.fromCharCode(a[h]);
    return s;
  }
  return _t.buf2binstring = function(a) {
    return n(a, a.length);
  }, _t.binstring2buf = function(a) {
    for (var l = new e.Buf8(a.length), s = 0, h = l.length; s < h; s++)
      l[s] = a.charCodeAt(s);
    return l;
  }, _t.buf2string = function(a, l) {
    var s, h, u, d, g = l || a.length, v = new Array(g * 2);
    for (h = 0, s = 0; s < g; ) {
      if (u = a[s++], u < 128) {
        v[h++] = u;
        continue;
      }
      if (d = i[u], d > 4) {
        v[h++] = 65533, s += d - 1;
        continue;
      }
      for (u &= d === 2 ? 31 : d === 3 ? 15 : 7; d > 1 && s < g; )
        u = u << 6 | a[s++] & 63, d--;
      if (d > 1) {
        v[h++] = 65533;
        continue;
      }
      u < 65536 ? v[h++] = u : (u -= 65536, v[h++] = 55296 | u >> 10 & 1023, v[h++] = 56320 | u & 1023);
    }
    return n(v, h);
  }, _t.utf8border = function(a, l) {
    var s;
    for (l = l || a.length, l > a.length && (l = a.length), s = l - 1; s >= 0 && (a[s] & 192) === 128; )
      s--;
    return s < 0 || s === 0 ? l : s + i[a[s]] > l ? s : l;
  }, _t;
}
var Wn, mi;
function La() {
  if (mi) return Wn;
  mi = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return Wn = e, Wn;
}
var yi;
function Vo() {
  if (yi) return zt;
  yi = 1;
  var e = Qo(), r = ct(), t = Da(), i = Dr(), f = La(), n = Object.prototype.toString, a = 0, l = 4, s = 0, h = 1, u = 2, d = -1, g = 0, v = 8;
  function c(x) {
    if (!(this instanceof c)) return new c(x);
    this.options = r.assign({
      level: d,
      method: v,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: g,
      to: ""
    }, x || {});
    var m = this.options;
    m.raw && m.windowBits > 0 ? m.windowBits = -m.windowBits : m.gzip && m.windowBits > 0 && m.windowBits < 16 && (m.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
    var k = e.deflateInit2(
      this.strm,
      m.level,
      m.method,
      m.windowBits,
      m.memLevel,
      m.strategy
    );
    if (k !== s)
      throw new Error(i[k]);
    if (m.header && e.deflateSetHeader(this.strm, m.header), m.dictionary) {
      var L;
      if (typeof m.dictionary == "string" ? L = t.string2buf(m.dictionary) : n.call(m.dictionary) === "[object ArrayBuffer]" ? L = new Uint8Array(m.dictionary) : L = m.dictionary, k = e.deflateSetDictionary(this.strm, L), k !== s)
        throw new Error(i[k]);
      this._dict_set = !0;
    }
  }
  c.prototype.push = function(x, m) {
    var k = this.strm, L = this.options.chunkSize, z, E;
    if (this.ended)
      return !1;
    E = m === ~~m ? m : m === !0 ? l : a, typeof x == "string" ? k.input = t.string2buf(x) : n.call(x) === "[object ArrayBuffer]" ? k.input = new Uint8Array(x) : k.input = x, k.next_in = 0, k.avail_in = k.input.length;
    do {
      if (k.avail_out === 0 && (k.output = new r.Buf8(L), k.next_out = 0, k.avail_out = L), z = e.deflate(k, E), z !== h && z !== s)
        return this.onEnd(z), this.ended = !0, !1;
      (k.avail_out === 0 || k.avail_in === 0 && (E === l || E === u)) && (this.options.to === "string" ? this.onData(t.buf2binstring(r.shrinkBuf(k.output, k.next_out))) : this.onData(r.shrinkBuf(k.output, k.next_out)));
    } while ((k.avail_in > 0 || k.avail_out === 0) && z !== h);
    return E === l ? (z = e.deflateEnd(this.strm), this.onEnd(z), this.ended = !0, z === s) : (E === u && (this.onEnd(s), k.avail_out = 0), !0);
  }, c.prototype.onData = function(x) {
    this.chunks.push(x);
  }, c.prototype.onEnd = function(x) {
    x === s && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
  };
  function R(x, m) {
    var k = new c(m);
    if (k.push(x, !0), k.err)
      throw k.msg || i[k.err];
    return k.result;
  }
  function S(x, m) {
    return m = m || {}, m.raw = !0, R(x, m);
  }
  function b(x, m) {
    return m = m || {}, m.gzip = !0, R(x, m);
  }
  return zt.Deflate = c, zt.deflate = R, zt.deflateRaw = S, zt.gzip = b, zt;
}
var Ct = {}, Ue = {}, Gn, Ai;
function jo() {
  if (Ai) return Gn;
  Ai = 1;
  var e = 30, r = 12;
  return Gn = function(i, f) {
    var n, a, l, s, h, u, d, g, v, c, R, S, b, x, m, k, L, z, E, T, I, D, C, O, N;
    n = i.state, a = i.next_in, O = i.input, l = a + (i.avail_in - 5), s = i.next_out, N = i.output, h = s - (f - i.avail_out), u = s + (i.avail_out - 257), d = n.dmax, g = n.wsize, v = n.whave, c = n.wnext, R = n.window, S = n.hold, b = n.bits, x = n.lencode, m = n.distcode, k = (1 << n.lenbits) - 1, L = (1 << n.distbits) - 1;
    e:
      do {
        b < 15 && (S += O[a++] << b, b += 8, S += O[a++] << b, b += 8), z = x[S & k];
        t:
          for (; ; ) {
            if (E = z >>> 24, S >>>= E, b -= E, E = z >>> 16 & 255, E === 0)
              N[s++] = z & 65535;
            else if (E & 16) {
              T = z & 65535, E &= 15, E && (b < E && (S += O[a++] << b, b += 8), T += S & (1 << E) - 1, S >>>= E, b -= E), b < 15 && (S += O[a++] << b, b += 8, S += O[a++] << b, b += 8), z = m[S & L];
              n:
                for (; ; ) {
                  if (E = z >>> 24, S >>>= E, b -= E, E = z >>> 16 & 255, E & 16) {
                    if (I = z & 65535, E &= 15, b < E && (S += O[a++] << b, b += 8, b < E && (S += O[a++] << b, b += 8)), I += S & (1 << E) - 1, I > d) {
                      i.msg = "invalid distance too far back", n.mode = e;
                      break e;
                    }
                    if (S >>>= E, b -= E, E = s - h, I > E) {
                      if (E = I - E, E > v && n.sane) {
                        i.msg = "invalid distance too far back", n.mode = e;
                        break e;
                      }
                      if (D = 0, C = R, c === 0) {
                        if (D += g - E, E < T) {
                          T -= E;
                          do
                            N[s++] = R[D++];
                          while (--E);
                          D = s - I, C = N;
                        }
                      } else if (c < E) {
                        if (D += g + c - E, E -= c, E < T) {
                          T -= E;
                          do
                            N[s++] = R[D++];
                          while (--E);
                          if (D = 0, c < T) {
                            E = c, T -= E;
                            do
                              N[s++] = R[D++];
                            while (--E);
                            D = s - I, C = N;
                          }
                        }
                      } else if (D += c - E, E < T) {
                        T -= E;
                        do
                          N[s++] = R[D++];
                        while (--E);
                        D = s - I, C = N;
                      }
                      for (; T > 2; )
                        N[s++] = C[D++], N[s++] = C[D++], N[s++] = C[D++], T -= 3;
                      T && (N[s++] = C[D++], T > 1 && (N[s++] = C[D++]));
                    } else {
                      D = s - I;
                      do
                        N[s++] = N[D++], N[s++] = N[D++], N[s++] = N[D++], T -= 3;
                      while (T > 2);
                      T && (N[s++] = N[D++], T > 1 && (N[s++] = N[D++]));
                    }
                  } else if ((E & 64) === 0) {
                    z = m[(z & 65535) + (S & (1 << E) - 1)];
                    continue n;
                  } else {
                    i.msg = "invalid distance code", n.mode = e;
                    break e;
                  }
                  break;
                }
            } else if ((E & 64) === 0) {
              z = x[(z & 65535) + (S & (1 << E) - 1)];
              continue t;
            } else if (E & 32) {
              n.mode = r;
              break e;
            } else {
              i.msg = "invalid literal/length code", n.mode = e;
              break e;
            }
            break;
          }
      } while (a < l && s < u);
    T = b >> 3, a -= T, b -= T << 3, S &= (1 << b) - 1, i.next_in = a, i.next_out = s, i.avail_in = a < l ? 5 + (l - a) : 5 - (a - l), i.avail_out = s < u ? 257 + (u - s) : 257 - (s - u), n.hold = S, n.bits = b;
  }, Gn;
}
var er, Si;
function Xo() {
  if (Si) return er;
  Si = 1;
  var e = ct(), r = 15, t = 852, i = 592, f = 0, n = 1, a = 2, l = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], s = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], h = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], u = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return er = function(g, v, c, R, S, b, x, m) {
    var k = m.bits, L = 0, z = 0, E = 0, T = 0, I = 0, D = 0, C = 0, O = 0, N = 0, U = 0, X, Y, q, V, ne, ve = null, be = 0, de, he = new e.Buf16(r + 1), ge = new e.Buf16(r + 1), ue = null, re = 0, ie, G, W;
    for (L = 0; L <= r; L++)
      he[L] = 0;
    for (z = 0; z < R; z++)
      he[v[c + z]]++;
    for (I = k, T = r; T >= 1 && he[T] === 0; T--)
      ;
    if (I > T && (I = T), T === 0)
      return S[b++] = 1 << 24 | 64 << 16 | 0, S[b++] = 1 << 24 | 64 << 16 | 0, m.bits = 1, 0;
    for (E = 1; E < T && he[E] === 0; E++)
      ;
    for (I < E && (I = E), O = 1, L = 1; L <= r; L++)
      if (O <<= 1, O -= he[L], O < 0)
        return -1;
    if (O > 0 && (g === f || T !== 1))
      return -1;
    for (ge[1] = 0, L = 1; L < r; L++)
      ge[L + 1] = ge[L] + he[L];
    for (z = 0; z < R; z++)
      v[c + z] !== 0 && (x[ge[v[c + z]]++] = z);
    if (g === f ? (ve = ue = x, de = 19) : g === n ? (ve = l, be -= 257, ue = s, re -= 257, de = 256) : (ve = h, ue = u, de = -1), U = 0, z = 0, L = E, ne = b, D = I, C = 0, q = -1, N = 1 << I, V = N - 1, g === n && N > t || g === a && N > i)
      return 1;
    for (; ; ) {
      ie = L - C, x[z] < de ? (G = 0, W = x[z]) : x[z] > de ? (G = ue[re + x[z]], W = ve[be + x[z]]) : (G = 96, W = 0), X = 1 << L - C, Y = 1 << D, E = Y;
      do
        Y -= X, S[ne + (U >> C) + Y] = ie << 24 | G << 16 | W | 0;
      while (Y !== 0);
      for (X = 1 << L - 1; U & X; )
        X >>= 1;
      if (X !== 0 ? (U &= X - 1, U += X) : U = 0, z++, --he[L] === 0) {
        if (L === T)
          break;
        L = v[c + x[z]];
      }
      if (L > I && (U & V) !== q) {
        for (C === 0 && (C = I), ne += E, D = L - C, O = 1 << D; D + C < T && (O -= he[D + C], !(O <= 0)); )
          D++, O <<= 1;
        if (N += 1 << D, g === n && N > t || g === a && N > i)
          return 1;
        q = U & V, S[q] = I << 24 | D << 16 | ne - b | 0;
      }
    }
    return U !== 0 && (S[ne + U] = L - C << 24 | 64 << 16 | 0), m.bits = I, 0;
  }, er;
}
var Ri;
function Jo() {
  if (Ri) return Ue;
  Ri = 1;
  var e = ct(), r = Ca(), t = Ia(), i = jo(), f = Xo(), n = 0, a = 1, l = 2, s = 4, h = 5, u = 6, d = 0, g = 1, v = 2, c = -2, R = -3, S = -4, b = -5, x = 8, m = 1, k = 2, L = 3, z = 4, E = 5, T = 6, I = 7, D = 8, C = 9, O = 10, N = 11, U = 12, X = 13, Y = 14, q = 15, V = 16, ne = 17, ve = 18, be = 19, de = 20, he = 21, ge = 22, ue = 23, re = 24, ie = 25, G = 26, W = 27, Ee = 28, ze = 29, te = 30, pe = 31, Ne = 32, Ie = 852, ye = 592, ce = 15, ae = ce;
  function Ze(A) {
    return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((A & 65280) << 8) + ((A & 255) << 24);
  }
  function yt() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function rt(A) {
    var H;
    return !A || !A.state ? c : (H = A.state, A.total_in = A.total_out = H.total = 0, A.msg = "", H.wrap && (A.adler = H.wrap & 1), H.mode = m, H.last = 0, H.havedict = 0, H.dmax = 32768, H.head = null, H.hold = 0, H.bits = 0, H.lencode = H.lendyn = new e.Buf32(Ie), H.distcode = H.distdyn = new e.Buf32(ye), H.sane = 1, H.back = -1, d);
  }
  function Oe(A) {
    var H;
    return !A || !A.state ? c : (H = A.state, H.wsize = 0, H.whave = 0, H.wnext = 0, rt(A));
  }
  function At(A, H) {
    var _, $;
    return !A || !A.state || ($ = A.state, H < 0 ? (_ = 0, H = -H) : (_ = (H >> 4) + 1, H < 48 && (H &= 15)), H && (H < 8 || H > 15)) ? c : ($.window !== null && $.wbits !== H && ($.window = null), $.wrap = _, $.wbits = H, Oe(A));
  }
  function it(A, H) {
    var _, $;
    return A ? ($ = new yt(), A.state = $, $.window = null, _ = At(A, H), _ !== d && (A.state = null), _) : c;
  }
  function Pe(A) {
    return it(A, ae);
  }
  var St = !0, at, Re;
  function Ke(A) {
    if (St) {
      var H;
      for (at = new e.Buf32(512), Re = new e.Buf32(32), H = 0; H < 144; )
        A.lens[H++] = 8;
      for (; H < 256; )
        A.lens[H++] = 9;
      for (; H < 280; )
        A.lens[H++] = 7;
      for (; H < 288; )
        A.lens[H++] = 8;
      for (f(a, A.lens, 0, 288, at, 0, A.work, { bits: 9 }), H = 0; H < 32; )
        A.lens[H++] = 5;
      f(l, A.lens, 0, 32, Re, 0, A.work, { bits: 5 }), St = !1;
    }
    A.lencode = at, A.lenbits = 9, A.distcode = Re, A.distbits = 5;
  }
  function Rt(A, H, _, $) {
    var ee, o = A.state;
    return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new e.Buf8(o.wsize)), $ >= o.wsize ? (e.arraySet(o.window, H, _ - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : (ee = o.wsize - o.wnext, ee > $ && (ee = $), e.arraySet(o.window, H, _ - $, ee, o.wnext), $ -= ee, $ ? (e.arraySet(o.window, H, _ - $, $, 0), o.wnext = $, o.whave = o.wsize) : (o.wnext += ee, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += ee))), 0;
  }
  function p(A, H) {
    var _, $, ee, o, M, Z, w, y, B, J, K, Q, fe, We, we = 0, le, ke, Te, De, on, fn, xe, He, Ae = new e.Buf8(4), Ge, Ye, Fr = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0)
      return c;
    _ = A.state, _.mode === U && (_.mode = X), M = A.next_out, ee = A.output, w = A.avail_out, o = A.next_in, $ = A.input, Z = A.avail_in, y = _.hold, B = _.bits, J = Z, K = w, He = d;
    e:
      for (; ; )
        switch (_.mode) {
          case m:
            if (_.wrap === 0) {
              _.mode = X;
              break;
            }
            for (; B < 16; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if (_.wrap & 2 && y === 35615) {
              _.check = 0, Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0), y = 0, B = 0, _.mode = k;
              break;
            }
            if (_.flags = 0, _.head && (_.head.done = !1), !(_.wrap & 1) || /* check if zlib header allowed */
            (((y & 255) << 8) + (y >> 8)) % 31) {
              A.msg = "incorrect header check", _.mode = te;
              break;
            }
            if ((y & 15) !== x) {
              A.msg = "unknown compression method", _.mode = te;
              break;
            }
            if (y >>>= 4, B -= 4, xe = (y & 15) + 8, _.wbits === 0)
              _.wbits = xe;
            else if (xe > _.wbits) {
              A.msg = "invalid window size", _.mode = te;
              break;
            }
            _.dmax = 1 << xe, A.adler = _.check = 1, _.mode = y & 512 ? O : U, y = 0, B = 0;
            break;
          case k:
            for (; B < 16; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if (_.flags = y, (_.flags & 255) !== x) {
              A.msg = "unknown compression method", _.mode = te;
              break;
            }
            if (_.flags & 57344) {
              A.msg = "unknown header flags set", _.mode = te;
              break;
            }
            _.head && (_.head.text = y >> 8 & 1), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0, _.mode = L;
          /* falls through */
          case L:
            for (; B < 32; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            _.head && (_.head.time = y), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, Ae[2] = y >>> 16 & 255, Ae[3] = y >>> 24 & 255, _.check = t(_.check, Ae, 4, 0)), y = 0, B = 0, _.mode = z;
          /* falls through */
          case z:
            for (; B < 16; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            _.head && (_.head.xflags = y & 255, _.head.os = y >> 8), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0, _.mode = E;
          /* falls through */
          case E:
            if (_.flags & 1024) {
              for (; B < 16; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              _.length = y, _.head && (_.head.extra_len = y), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0;
            } else _.head && (_.head.extra = null);
            _.mode = T;
          /* falls through */
          case T:
            if (_.flags & 1024 && (Q = _.length, Q > Z && (Q = Z), Q && (_.head && (xe = _.head.extra_len - _.length, _.head.extra || (_.head.extra = new Array(_.head.extra_len)), e.arraySet(
              _.head.extra,
              $,
              o,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              Q,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              xe
            )), _.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, _.length -= Q), _.length))
              break e;
            _.length = 0, _.mode = I;
          /* falls through */
          case I:
            if (_.flags & 2048) {
              if (Z === 0)
                break e;
              Q = 0;
              do
                xe = $[o + Q++], _.head && xe && _.length < 65536 && (_.head.name += String.fromCharCode(xe));
              while (xe && Q < Z);
              if (_.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, xe)
                break e;
            } else _.head && (_.head.name = null);
            _.length = 0, _.mode = D;
          /* falls through */
          case D:
            if (_.flags & 4096) {
              if (Z === 0)
                break e;
              Q = 0;
              do
                xe = $[o + Q++], _.head && xe && _.length < 65536 && (_.head.comment += String.fromCharCode(xe));
              while (xe && Q < Z);
              if (_.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, xe)
                break e;
            } else _.head && (_.head.comment = null);
            _.mode = C;
          /* falls through */
          case C:
            if (_.flags & 512) {
              for (; B < 16; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              if (y !== (_.check & 65535)) {
                A.msg = "header crc mismatch", _.mode = te;
                break;
              }
              y = 0, B = 0;
            }
            _.head && (_.head.hcrc = _.flags >> 9 & 1, _.head.done = !0), A.adler = _.check = 0, _.mode = U;
            break;
          case O:
            for (; B < 32; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            A.adler = _.check = Ze(y), y = 0, B = 0, _.mode = N;
          /* falls through */
          case N:
            if (_.havedict === 0)
              return A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, v;
            A.adler = _.check = 1, _.mode = U;
          /* falls through */
          case U:
            if (H === h || H === u)
              break e;
          /* falls through */
          case X:
            if (_.last) {
              y >>>= B & 7, B -= B & 7, _.mode = W;
              break;
            }
            for (; B < 3; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            switch (_.last = y & 1, y >>>= 1, B -= 1, y & 3) {
              case 0:
                _.mode = Y;
                break;
              case 1:
                if (Ke(_), _.mode = de, H === u) {
                  y >>>= 2, B -= 2;
                  break e;
                }
                break;
              case 2:
                _.mode = ne;
                break;
              case 3:
                A.msg = "invalid block type", _.mode = te;
            }
            y >>>= 2, B -= 2;
            break;
          case Y:
            for (y >>>= B & 7, B -= B & 7; B < 32; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if ((y & 65535) !== (y >>> 16 ^ 65535)) {
              A.msg = "invalid stored block lengths", _.mode = te;
              break;
            }
            if (_.length = y & 65535, y = 0, B = 0, _.mode = q, H === u)
              break e;
          /* falls through */
          case q:
            _.mode = V;
          /* falls through */
          case V:
            if (Q = _.length, Q) {
              if (Q > Z && (Q = Z), Q > w && (Q = w), Q === 0)
                break e;
              e.arraySet(ee, $, o, Q, M), Z -= Q, o += Q, w -= Q, M += Q, _.length -= Q;
              break;
            }
            _.mode = U;
            break;
          case ne:
            for (; B < 14; ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if (_.nlen = (y & 31) + 257, y >>>= 5, B -= 5, _.ndist = (y & 31) + 1, y >>>= 5, B -= 5, _.ncode = (y & 15) + 4, y >>>= 4, B -= 4, _.nlen > 286 || _.ndist > 30) {
              A.msg = "too many length or distance symbols", _.mode = te;
              break;
            }
            _.have = 0, _.mode = ve;
          /* falls through */
          case ve:
            for (; _.have < _.ncode; ) {
              for (; B < 3; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              _.lens[Fr[_.have++]] = y & 7, y >>>= 3, B -= 3;
            }
            for (; _.have < 19; )
              _.lens[Fr[_.have++]] = 0;
            if (_.lencode = _.lendyn, _.lenbits = 7, Ge = { bits: _.lenbits }, He = f(n, _.lens, 0, 19, _.lencode, 0, _.work, Ge), _.lenbits = Ge.bits, He) {
              A.msg = "invalid code lengths set", _.mode = te;
              break;
            }
            _.have = 0, _.mode = be;
          /* falls through */
          case be:
            for (; _.have < _.nlen + _.ndist; ) {
              for (; we = _.lencode[y & (1 << _.lenbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              if (Te < 16)
                y >>>= le, B -= le, _.lens[_.have++] = Te;
              else {
                if (Te === 16) {
                  for (Ye = le + 2; B < Ye; ) {
                    if (Z === 0)
                      break e;
                    Z--, y += $[o++] << B, B += 8;
                  }
                  if (y >>>= le, B -= le, _.have === 0) {
                    A.msg = "invalid bit length repeat", _.mode = te;
                    break;
                  }
                  xe = _.lens[_.have - 1], Q = 3 + (y & 3), y >>>= 2, B -= 2;
                } else if (Te === 17) {
                  for (Ye = le + 3; B < Ye; ) {
                    if (Z === 0)
                      break e;
                    Z--, y += $[o++] << B, B += 8;
                  }
                  y >>>= le, B -= le, xe = 0, Q = 3 + (y & 7), y >>>= 3, B -= 3;
                } else {
                  for (Ye = le + 7; B < Ye; ) {
                    if (Z === 0)
                      break e;
                    Z--, y += $[o++] << B, B += 8;
                  }
                  y >>>= le, B -= le, xe = 0, Q = 11 + (y & 127), y >>>= 7, B -= 7;
                }
                if (_.have + Q > _.nlen + _.ndist) {
                  A.msg = "invalid bit length repeat", _.mode = te;
                  break;
                }
                for (; Q--; )
                  _.lens[_.have++] = xe;
              }
            }
            if (_.mode === te)
              break;
            if (_.lens[256] === 0) {
              A.msg = "invalid code -- missing end-of-block", _.mode = te;
              break;
            }
            if (_.lenbits = 9, Ge = { bits: _.lenbits }, He = f(a, _.lens, 0, _.nlen, _.lencode, 0, _.work, Ge), _.lenbits = Ge.bits, He) {
              A.msg = "invalid literal/lengths set", _.mode = te;
              break;
            }
            if (_.distbits = 6, _.distcode = _.distdyn, Ge = { bits: _.distbits }, He = f(l, _.lens, _.nlen, _.ndist, _.distcode, 0, _.work, Ge), _.distbits = Ge.bits, He) {
              A.msg = "invalid distances set", _.mode = te;
              break;
            }
            if (_.mode = de, H === u)
              break e;
          /* falls through */
          case de:
            _.mode = he;
          /* falls through */
          case he:
            if (Z >= 6 && w >= 258) {
              A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, i(A, K), M = A.next_out, ee = A.output, w = A.avail_out, o = A.next_in, $ = A.input, Z = A.avail_in, y = _.hold, B = _.bits, _.mode === U && (_.back = -1);
              break;
            }
            for (_.back = 0; we = _.lencode[y & (1 << _.lenbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if (ke && (ke & 240) === 0) {
              for (De = le, on = ke, fn = Te; we = _.lencode[fn + ((y & (1 << De + on) - 1) >> De)], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(De + le <= B); ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              y >>>= De, B -= De, _.back += De;
            }
            if (y >>>= le, B -= le, _.back += le, _.length = Te, ke === 0) {
              _.mode = G;
              break;
            }
            if (ke & 32) {
              _.back = -1, _.mode = U;
              break;
            }
            if (ke & 64) {
              A.msg = "invalid literal/length code", _.mode = te;
              break;
            }
            _.extra = ke & 15, _.mode = ge;
          /* falls through */
          case ge:
            if (_.extra) {
              for (Ye = _.extra; B < Ye; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              _.length += y & (1 << _.extra) - 1, y >>>= _.extra, B -= _.extra, _.back += _.extra;
            }
            _.was = _.length, _.mode = ue;
          /* falls through */
          case ue:
            for (; we = _.distcode[y & (1 << _.distbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {
              if (Z === 0)
                break e;
              Z--, y += $[o++] << B, B += 8;
            }
            if ((ke & 240) === 0) {
              for (De = le, on = ke, fn = Te; we = _.distcode[fn + ((y & (1 << De + on) - 1) >> De)], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(De + le <= B); ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              y >>>= De, B -= De, _.back += De;
            }
            if (y >>>= le, B -= le, _.back += le, ke & 64) {
              A.msg = "invalid distance code", _.mode = te;
              break;
            }
            _.offset = Te, _.extra = ke & 15, _.mode = re;
          /* falls through */
          case re:
            if (_.extra) {
              for (Ye = _.extra; B < Ye; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              _.offset += y & (1 << _.extra) - 1, y >>>= _.extra, B -= _.extra, _.back += _.extra;
            }
            if (_.offset > _.dmax) {
              A.msg = "invalid distance too far back", _.mode = te;
              break;
            }
            _.mode = ie;
          /* falls through */
          case ie:
            if (w === 0)
              break e;
            if (Q = K - w, _.offset > Q) {
              if (Q = _.offset - Q, Q > _.whave && _.sane) {
                A.msg = "invalid distance too far back", _.mode = te;
                break;
              }
              Q > _.wnext ? (Q -= _.wnext, fe = _.wsize - Q) : fe = _.wnext - Q, Q > _.length && (Q = _.length), We = _.window;
            } else
              We = ee, fe = M - _.offset, Q = _.length;
            Q > w && (Q = w), w -= Q, _.length -= Q;
            do
              ee[M++] = We[fe++];
            while (--Q);
            _.length === 0 && (_.mode = he);
            break;
          case G:
            if (w === 0)
              break e;
            ee[M++] = _.length, w--, _.mode = he;
            break;
          case W:
            if (_.wrap) {
              for (; B < 32; ) {
                if (Z === 0)
                  break e;
                Z--, y |= $[o++] << B, B += 8;
              }
              if (K -= w, A.total_out += K, _.total += K, K && (A.adler = _.check = /*UPDATE(state.check, put - _out, _out);*/
              _.flags ? t(_.check, ee, K, M - K) : r(_.check, ee, K, M - K)), K = w, (_.flags ? y : Ze(y)) !== _.check) {
                A.msg = "incorrect data check", _.mode = te;
                break;
              }
              y = 0, B = 0;
            }
            _.mode = Ee;
          /* falls through */
          case Ee:
            if (_.wrap && _.flags) {
              for (; B < 32; ) {
                if (Z === 0)
                  break e;
                Z--, y += $[o++] << B, B += 8;
              }
              if (y !== (_.total & 4294967295)) {
                A.msg = "incorrect length check", _.mode = te;
                break;
              }
              y = 0, B = 0;
            }
            _.mode = ze;
          /* falls through */
          case ze:
            He = g;
            break e;
          case te:
            He = R;
            break e;
          case pe:
            return S;
          case Ne:
          /* falls through */
          default:
            return c;
        }
    return A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, (_.wsize || K !== A.avail_out && _.mode < te && (_.mode < W || H !== s)) && Rt(A, A.output, A.next_out, K - A.avail_out), J -= A.avail_in, K -= A.avail_out, A.total_in += J, A.total_out += K, _.total += K, _.wrap && K && (A.adler = _.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    _.flags ? t(_.check, ee, K, A.next_out - K) : r(_.check, ee, K, A.next_out - K)), A.data_type = _.bits + (_.last ? 64 : 0) + (_.mode === U ? 128 : 0) + (_.mode === de || _.mode === q ? 256 : 0), (J === 0 && K === 0 || H === s) && He === d && (He = b), He;
  }
  function F(A) {
    if (!A || !A.state)
      return c;
    var H = A.state;
    return H.window && (H.window = null), A.state = null, d;
  }
  function P(A, H) {
    var _;
    return !A || !A.state || (_ = A.state, (_.wrap & 2) === 0) ? c : (_.head = H, H.done = !1, d);
  }
  function j(A, H) {
    var _ = H.length, $, ee, o;
    return !A || !A.state || ($ = A.state, $.wrap !== 0 && $.mode !== N) ? c : $.mode === N && (ee = 1, ee = r(ee, H, _, 0), ee !== $.check) ? R : (o = Rt(A, H, _, _), o ? ($.mode = pe, S) : ($.havedict = 1, d));
  }
  return Ue.inflateReset = Oe, Ue.inflateReset2 = At, Ue.inflateResetKeep = rt, Ue.inflateInit = Pe, Ue.inflateInit2 = it, Ue.inflate = p, Ue.inflateEnd = F, Ue.inflateGetHeader = P, Ue.inflateSetDictionary = j, Ue.inflateInfo = "pako inflate (from Nodeca project)", Ue;
}
var tr, Ti;
function Ba() {
  return Ti || (Ti = 1, tr = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), tr;
}
var nr, zi;
function Wo() {
  if (zi) return nr;
  zi = 1;
  function e() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
  }
  return nr = e, nr;
}
var Ci;
function Go() {
  if (Ci) return Ct;
  Ci = 1;
  var e = Jo(), r = ct(), t = Da(), i = Ba(), f = Dr(), n = La(), a = Wo(), l = Object.prototype.toString;
  function s(d) {
    if (!(this instanceof s)) return new s(d);
    this.options = r.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, d || {});
    var g = this.options;
    g.raw && g.windowBits >= 0 && g.windowBits < 16 && (g.windowBits = -g.windowBits, g.windowBits === 0 && (g.windowBits = -15)), g.windowBits >= 0 && g.windowBits < 16 && !(d && d.windowBits) && (g.windowBits += 32), g.windowBits > 15 && g.windowBits < 48 && (g.windowBits & 15) === 0 && (g.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
    var v = e.inflateInit2(
      this.strm,
      g.windowBits
    );
    if (v !== i.Z_OK)
      throw new Error(f[v]);
    if (this.header = new a(), e.inflateGetHeader(this.strm, this.header), g.dictionary && (typeof g.dictionary == "string" ? g.dictionary = t.string2buf(g.dictionary) : l.call(g.dictionary) === "[object ArrayBuffer]" && (g.dictionary = new Uint8Array(g.dictionary)), g.raw && (v = e.inflateSetDictionary(this.strm, g.dictionary), v !== i.Z_OK)))
      throw new Error(f[v]);
  }
  s.prototype.push = function(d, g) {
    var v = this.strm, c = this.options.chunkSize, R = this.options.dictionary, S, b, x, m, k, L = !1;
    if (this.ended)
      return !1;
    b = g === ~~g ? g : g === !0 ? i.Z_FINISH : i.Z_NO_FLUSH, typeof d == "string" ? v.input = t.binstring2buf(d) : l.call(d) === "[object ArrayBuffer]" ? v.input = new Uint8Array(d) : v.input = d, v.next_in = 0, v.avail_in = v.input.length;
    do {
      if (v.avail_out === 0 && (v.output = new r.Buf8(c), v.next_out = 0, v.avail_out = c), S = e.inflate(v, i.Z_NO_FLUSH), S === i.Z_NEED_DICT && R && (S = e.inflateSetDictionary(this.strm, R)), S === i.Z_BUF_ERROR && L === !0 && (S = i.Z_OK, L = !1), S !== i.Z_STREAM_END && S !== i.Z_OK)
        return this.onEnd(S), this.ended = !0, !1;
      v.next_out && (v.avail_out === 0 || S === i.Z_STREAM_END || v.avail_in === 0 && (b === i.Z_FINISH || b === i.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (x = t.utf8border(v.output, v.next_out), m = v.next_out - x, k = t.buf2string(v.output, x), v.next_out = m, v.avail_out = c - m, m && r.arraySet(v.output, v.output, x, m, 0), this.onData(k)) : this.onData(r.shrinkBuf(v.output, v.next_out))), v.avail_in === 0 && v.avail_out === 0 && (L = !0);
    } while ((v.avail_in > 0 || v.avail_out === 0) && S !== i.Z_STREAM_END);
    return S === i.Z_STREAM_END && (b = i.Z_FINISH), b === i.Z_FINISH ? (S = e.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === i.Z_OK) : (b === i.Z_SYNC_FLUSH && (this.onEnd(i.Z_OK), v.avail_out = 0), !0);
  }, s.prototype.onData = function(d) {
    this.chunks.push(d);
  }, s.prototype.onEnd = function(d) {
    d === i.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = d, this.msg = this.strm.msg;
  };
  function h(d, g) {
    var v = new s(g);
    if (v.push(d, !0), v.err)
      throw v.msg || f[v.err];
    return v.result;
  }
  function u(d, g) {
    return g = g || {}, g.raw = !0, h(d, g);
  }
  return Ct.Inflate = s, Ct.inflate = h, Ct.inflateRaw = u, Ct.ungzip = h, Ct;
}
var rr, Ii;
function ef() {
  if (Ii) return rr;
  Ii = 1;
  var e = ct().assign, r = Vo(), t = Go(), i = Ba(), f = {};
  return e(f, r, t, i), rr = f, rr;
}
var Di;
function tf() {
  return Di || (Di = 1, function(e) {
    (function() {
      var r = {}, t;
      e.exports = r, typeof Ko == "function" ? t = ef() : t = window.pako, function(i, f) {
        i.toRGBA8 = function(n) {
          var a = n.width, l = n.height;
          if (n.tabs.acTL == null) return [i.toRGBA8.decodeImage(n.data, a, l, n).buffer];
          var s = [];
          n.frames[0].data == null && (n.frames[0].data = n.data);
          for (var h, u = new Uint8Array(a * l * 4), d = 0; d < n.frames.length; d++) {
            var g = n.frames[d], v = g.rect.x, c = g.rect.y, R = g.rect.width, S = g.rect.height, b = i.toRGBA8.decodeImage(g.data, R, S, n);
            if (d == 0 ? h = b : g.blend == 0 ? i._copyTile(b, R, S, h, a, l, v, c, 0) : g.blend == 1 && i._copyTile(b, R, S, h, a, l, v, c, 1), s.push(h.buffer), h = h.slice(0), g.dispose != 0) {
              if (g.dispose == 1) i._copyTile(u, R, S, h, a, l, v, c, 0);
              else if (g.dispose == 2) {
                for (var x = d - 1; n.frames[x].dispose == 2; ) x--;
                h = new Uint8Array(s[x]).slice(0);
              }
            }
          }
          return s;
        }, i.toRGBA8.decodeImage = function(n, a, l, s) {
          var h = a * l, u = i.decode._getBPP(s), d = Math.ceil(a * u / 8), g = new Uint8Array(h * 4), v = new Uint32Array(g.buffer), c = s.ctype, R = s.depth, S = i._bin.readUshort;
          if (c == 6) {
            var b = h << 2;
            if (R == 8) for (var x = 0; x < b; x++)
              g[x] = n[x];
            if (R == 16) for (var x = 0; x < b; x++)
              g[x] = n[x << 1];
          } else if (c == 2) {
            var m = s.tabs.tRNS, k = -1, L = -1, z = -1;
            if (m && (k = m[0], L = m[1], z = m[2]), R == 8) for (var x = 0; x < h; x++) {
              var E = x << 2, T = x * 3;
              g[E] = n[T], g[E + 1] = n[T + 1], g[E + 2] = n[T + 2], g[E + 3] = 255, k != -1 && n[T] == k && n[T + 1] == L && n[T + 2] == z && (g[E + 3] = 0);
            }
            if (R == 16) for (var x = 0; x < h; x++) {
              var E = x << 2, T = x * 6;
              g[E] = n[T], g[E + 1] = n[T + 2], g[E + 2] = n[T + 4], g[E + 3] = 255, k != -1 && S(n, T) == k && S(n, T + 2) == L && S(n, T + 4) == z && (g[E + 3] = 0);
            }
          } else if (c == 3) {
            var I = s.tabs.PLTE, D = s.tabs.tRNS, C = D ? D.length : 0;
            if (R == 1) for (var O = 0; O < l; O++)
              for (var N = O * d, U = O * a, x = 0; x < a; x++) {
                var E = U + x << 2, X = n[N + (x >> 3)] >> 7 - ((x & 7) << 0) & 1, Y = 3 * X;
                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;
              }
            if (R == 2) for (var O = 0; O < l; O++)
              for (var N = O * d, U = O * a, x = 0; x < a; x++) {
                var E = U + x << 2, X = n[N + (x >> 2)] >> 6 - ((x & 3) << 1) & 3, Y = 3 * X;
                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;
              }
            if (R == 4) for (var O = 0; O < l; O++)
              for (var N = O * d, U = O * a, x = 0; x < a; x++) {
                var E = U + x << 2, X = n[N + (x >> 1)] >> 4 - ((x & 1) << 2) & 15, Y = 3 * X;
                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;
              }
            if (R == 8) for (var x = 0; x < h; x++) {
              var E = x << 2, X = n[x], Y = 3 * X;
              g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;
            }
          } else if (c == 4) {
            if (R == 8) for (var x = 0; x < h; x++) {
              var E = x << 2, q = x << 1, V = n[q];
              g[E] = V, g[E + 1] = V, g[E + 2] = V, g[E + 3] = n[q + 1];
            }
            if (R == 16) for (var x = 0; x < h; x++) {
              var E = x << 2, q = x << 2, V = n[q];
              g[E] = V, g[E + 1] = V, g[E + 2] = V, g[E + 3] = n[q + 2];
            }
          } else if (c == 0) {
            var k = s.tabs.tRNS ? s.tabs.tRNS : -1;
            if (R == 1) for (var x = 0; x < h; x++) {
              var V = 255 * (n[x >> 3] >> 7 - (x & 7) & 1), ne = V == k * 255 ? 0 : 255;
              v[x] = ne << 24 | V << 16 | V << 8 | V;
            }
            if (R == 2) for (var x = 0; x < h; x++) {
              var V = 85 * (n[x >> 2] >> 6 - ((x & 3) << 1) & 3), ne = V == k * 85 ? 0 : 255;
              v[x] = ne << 24 | V << 16 | V << 8 | V;
            }
            if (R == 4) for (var x = 0; x < h; x++) {
              var V = 17 * (n[x >> 1] >> 4 - ((x & 1) << 2) & 15), ne = V == k * 17 ? 0 : 255;
              v[x] = ne << 24 | V << 16 | V << 8 | V;
            }
            if (R == 8) for (var x = 0; x < h; x++) {
              var V = n[x], ne = V == k ? 0 : 255;
              v[x] = ne << 24 | V << 16 | V << 8 | V;
            }
            if (R == 16) for (var x = 0; x < h; x++) {
              var V = n[x << 1], ne = S(n, x << 1) == k ? 0 : 255;
              v[x] = ne << 24 | V << 16 | V << 8 | V;
            }
          }
          return g;
        }, i.decode = function(n) {
          for (var a = new Uint8Array(n), l = 8, s = i._bin, h = s.readUshort, u = s.readUint, d = { tabs: {}, frames: [] }, g = new Uint8Array(a.length), v = 0, c, R = 0, S = [137, 80, 78, 71, 13, 10, 26, 10], b = 0; b < 8; b++) if (a[b] != S[b]) throw "The input is not a PNG file!";
          for (; l < a.length; ) {
            var x = s.readUint(a, l);
            l += 4;
            var m = s.readASCII(a, l, 4);
            if (l += 4, m == "IHDR")
              i.decode._IHDR(a, l, d);
            else if (m == "IDAT") {
              for (var b = 0; b < x; b++) g[v + b] = a[l + b];
              v += x;
            } else if (m == "acTL")
              d.tabs[m] = { num_frames: u(a, l), num_plays: u(a, l + 4) }, c = new Uint8Array(a.length);
            else if (m == "fcTL") {
              if (R != 0) {
                var k = d.frames[d.frames.length - 1];
                k.data = i.decode._decompress(d, c.slice(0, R), k.rect.width, k.rect.height), R = 0;
              }
              var L = { x: u(a, l + 12), y: u(a, l + 16), width: u(a, l + 4), height: u(a, l + 8) }, z = h(a, l + 22);
              z = h(a, l + 20) / (z == 0 ? 100 : z);
              var E = { rect: L, delay: Math.round(z * 1e3), dispose: a[l + 24], blend: a[l + 25] };
              d.frames.push(E);
            } else if (m == "fdAT") {
              for (var b = 0; b < x - 4; b++) c[R + b] = a[l + b + 4];
              R += x - 4;
            } else if (m == "pHYs")
              d.tabs[m] = [s.readUint(a, l), s.readUint(a, l + 4), a[l + 8]];
            else if (m == "cHRM") {
              d.tabs[m] = [];
              for (var b = 0; b < 8; b++) d.tabs[m].push(s.readUint(a, l + b * 4));
            } else if (m == "tEXt") {
              d.tabs[m] == null && (d.tabs[m] = {});
              var T = s.nextZero(a, l), I = s.readASCII(a, l, T - l), D = s.readASCII(a, T + 1, l + x - T - 1);
              d.tabs[m][I] = D;
            } else if (m == "iTXt") {
              d.tabs[m] == null && (d.tabs[m] = {});
              var T = 0, C = l;
              T = s.nextZero(a, C);
              var I = s.readASCII(a, C, T - C);
              C = T + 1, a[C], a[C + 1], C += 2, T = s.nextZero(a, C), s.readASCII(a, C, T - C), C = T + 1, T = s.nextZero(a, C), s.readUTF8(a, C, T - C), C = T + 1;
              var D = s.readUTF8(a, C, x - (C - l));
              d.tabs[m][I] = D;
            } else if (m == "PLTE")
              d.tabs[m] = s.readBytes(a, l, x);
            else if (m == "hIST") {
              var O = d.tabs.PLTE.length / 3;
              d.tabs[m] = [];
              for (var b = 0; b < O; b++) d.tabs[m].push(h(a, l + b * 2));
            } else if (m == "tRNS")
              d.ctype == 3 ? d.tabs[m] = s.readBytes(a, l, x) : d.ctype == 0 ? d.tabs[m] = h(a, l) : d.ctype == 2 && (d.tabs[m] = [h(a, l), h(a, l + 2), h(a, l + 4)]);
            else if (m == "gAMA") d.tabs[m] = s.readUint(a, l) / 1e5;
            else if (m == "sRGB") d.tabs[m] = a[l];
            else if (m == "bKGD")
              d.ctype == 0 || d.ctype == 4 ? d.tabs[m] = [h(a, l)] : d.ctype == 2 || d.ctype == 6 ? d.tabs[m] = [h(a, l), h(a, l + 2), h(a, l + 4)] : d.ctype == 3 && (d.tabs[m] = a[l]);
            else if (m == "IEND") {
              if (R != 0) {
                var k = d.frames[d.frames.length - 1];
                k.data = i.decode._decompress(d, c.slice(0, R), k.rect.width, k.rect.height), R = 0;
              }
              d.data = i.decode._decompress(d, g, d.width, d.height);
              break;
            }
            l += x, s.readUint(a, l), l += 4;
          }
          return delete d.compress, delete d.interlace, delete d.filter, d;
        }, i.decode._decompress = function(n, a, l, s) {
          return n.compress == 0 && (a = i.decode._inflate(a)), n.interlace == 0 ? a = i.decode._filterZero(a, n, 0, l, s) : n.interlace == 1 && (a = i.decode._readInterlace(a, n)), a;
        }, i.decode._inflate = function(n) {
          return f.inflate(n);
        }, i.decode._readInterlace = function(n, a) {
          for (var l = a.width, s = a.height, h = i.decode._getBPP(a), u = h >> 3, d = Math.ceil(l * h / 8), g = new Uint8Array(s * d), v = 0, c = [0, 0, 4, 0, 2, 0, 1], R = [0, 4, 0, 2, 0, 1, 0], S = [8, 8, 8, 4, 4, 2, 2], b = [8, 8, 4, 4, 2, 2, 1], x = 0; x < 7; ) {
            for (var m = S[x], k = b[x], L = 0, z = 0, E = c[x]; E < s; )
              E += m, z++;
            for (var T = R[x]; T < l; )
              T += k, L++;
            var I = Math.ceil(L * h / 8);
            i.decode._filterZero(n, a, v, L, z);
            for (var D = 0, C = c[x]; C < s; ) {
              for (var O = R[x], N = v + D * I << 3; O < l; ) {
                if (h == 1) {
                  var U = n[N >> 3];
                  U = U >> 7 - (N & 7) & 1, g[C * d + (O >> 3)] |= U << 7 - ((O & 3) << 0);
                }
                if (h == 2) {
                  var U = n[N >> 3];
                  U = U >> 6 - (N & 7) & 3, g[C * d + (O >> 2)] |= U << 6 - ((O & 3) << 1);
                }
                if (h == 4) {
                  var U = n[N >> 3];
                  U = U >> 4 - (N & 7) & 15, g[C * d + (O >> 1)] |= U << 4 - ((O & 1) << 2);
                }
                if (h >= 8)
                  for (var X = C * d + O * u, Y = 0; Y < u; Y++) g[X + Y] = n[(N >> 3) + Y];
                N += h, O += k;
              }
              D++, C += m;
            }
            L * z != 0 && (v += z * (1 + I)), x = x + 1;
          }
          return g;
        }, i.decode._getBPP = function(n) {
          var a = [1, null, 3, 1, 2, null, 4][n.ctype];
          return a * n.depth;
        }, i.decode._filterZero = function(n, a, l, s, h) {
          var u = i.decode._getBPP(a), d = Math.ceil(s * u / 8), g = i.decode._paeth;
          u = Math.ceil(u / 8);
          for (var v = 0; v < h; v++) {
            var c = l + v * d, R = c + v + 1, S = n[R - 1];
            if (S == 0) for (var b = 0; b < d; b++) n[c + b] = n[R + b];
            else if (S == 1) {
              for (var b = 0; b < u; b++) n[c + b] = n[R + b];
              for (var b = u; b < d; b++) n[c + b] = n[R + b] + n[c + b - u] & 255;
            } else if (v == 0) {
              for (var b = 0; b < u; b++) n[c + b] = n[R + b];
              if (S == 2) for (var b = u; b < d; b++) n[c + b] = n[R + b] & 255;
              if (S == 3) for (var b = u; b < d; b++) n[c + b] = n[R + b] + (n[c + b - u] >> 1) & 255;
              if (S == 4) for (var b = u; b < d; b++) n[c + b] = n[R + b] + g(n[c + b - u], 0, 0) & 255;
            } else {
              if (S == 2)
                for (var b = 0; b < d; b++) n[c + b] = n[R + b] + n[c + b - d] & 255;
              if (S == 3) {
                for (var b = 0; b < u; b++) n[c + b] = n[R + b] + (n[c + b - d] >> 1) & 255;
                for (var b = u; b < d; b++) n[c + b] = n[R + b] + (n[c + b - d] + n[c + b - u] >> 1) & 255;
              }
              if (S == 4) {
                for (var b = 0; b < u; b++) n[c + b] = n[R + b] + g(0, n[c + b - d], 0) & 255;
                for (var b = u; b < d; b++) n[c + b] = n[R + b] + g(n[c + b - u], n[c + b - d], n[c + b - u - d]) & 255;
              }
            }
          }
          return n;
        }, i.decode._paeth = function(n, a, l) {
          var s = n + a - l, h = Math.abs(s - n), u = Math.abs(s - a), d = Math.abs(s - l);
          return h <= u && h <= d ? n : u <= d ? a : l;
        }, i.decode._IHDR = function(n, a, l) {
          var s = i._bin;
          l.width = s.readUint(n, a), a += 4, l.height = s.readUint(n, a), a += 4, l.depth = n[a], a++, l.ctype = n[a], a++, l.compress = n[a], a++, l.filter = n[a], a++, l.interlace = n[a], a++;
        }, i._bin = {
          nextZero: function(n, a) {
            for (; n[a] != 0; ) a++;
            return a;
          },
          readUshort: function(n, a) {
            return n[a] << 8 | n[a + 1];
          },
          writeUshort: function(n, a, l) {
            n[a] = l >> 8 & 255, n[a + 1] = l & 255;
          },
          readUint: function(n, a) {
            return n[a] * (256 * 256 * 256) + (n[a + 1] << 16 | n[a + 2] << 8 | n[a + 3]);
          },
          writeUint: function(n, a, l) {
            n[a] = l >> 24 & 255, n[a + 1] = l >> 16 & 255, n[a + 2] = l >> 8 & 255, n[a + 3] = l & 255;
          },
          readASCII: function(n, a, l) {
            for (var s = "", h = 0; h < l; h++) s += String.fromCharCode(n[a + h]);
            return s;
          },
          writeASCII: function(n, a, l) {
            for (var s = 0; s < l.length; s++) n[a + s] = l.charCodeAt(s);
          },
          readBytes: function(n, a, l) {
            for (var s = [], h = 0; h < l; h++) s.push(n[a + h]);
            return s;
          },
          pad: function(n) {
            return n.length < 2 ? "0" + n : n;
          },
          readUTF8: function(n, a, l) {
            for (var s = "", h, u = 0; u < l; u++) s += "%" + i._bin.pad(n[a + u].toString(16));
            try {
              h = decodeURIComponent(s);
            } catch {
              return i._bin.readASCII(n, a, l);
            }
            return h;
          }
        }, i._copyTile = function(n, a, l, s, h, u, d, g, v) {
          for (var c = Math.min(a, h), R = Math.min(l, u), S = 0, b = 0, x = 0; x < R; x++)
            for (var m = 0; m < c; m++)
              if (d >= 0 && g >= 0 ? (S = x * a + m << 2, b = (g + x) * h + d + m << 2) : (S = (-g + x) * a - d + m << 2, b = x * h + m << 2), v == 0)
                s[b] = n[S], s[b + 1] = n[S + 1], s[b + 2] = n[S + 2], s[b + 3] = n[S + 3];
              else if (v == 1) {
                var k = n[S + 3] * 0.00392156862745098, L = n[S] * k, z = n[S + 1] * k, E = n[S + 2] * k, T = s[b + 3] * (1 / 255), I = s[b] * T, D = s[b + 1] * T, C = s[b + 2] * T, O = 1 - k, N = k + T * O, U = N == 0 ? 0 : 1 / N;
                s[b + 3] = 255 * N, s[b + 0] = (L + I * O) * U, s[b + 1] = (z + D * O) * U, s[b + 2] = (E + C * O) * U;
              } else if (v == 2) {
                var k = n[S + 3], L = n[S], z = n[S + 1], E = n[S + 2], T = s[b + 3], I = s[b], D = s[b + 1], C = s[b + 2];
                k == T && L == I && z == D && E == C ? (s[b] = 0, s[b + 1] = 0, s[b + 2] = 0, s[b + 3] = 0) : (s[b] = L, s[b + 1] = z, s[b + 2] = E, s[b + 3] = k);
              } else if (v == 3) {
                var k = n[S + 3], L = n[S], z = n[S + 1], E = n[S + 2], T = s[b + 3], I = s[b], D = s[b + 1], C = s[b + 2];
                if (k == T && L == I && z == D && E == C) continue;
                if (k < 220 && T > 20) return !1;
              }
          return !0;
        }, i.encode = function(n, a, l, s, h, u) {
          s == null && (s = 0), u == null && (u = !1);
          for (var d = new Uint8Array(n[0].byteLength * n.length + 100), g = [137, 80, 78, 71, 13, 10, 26, 10], v = 0; v < 8; v++) d[v] = g[v];
          var c = 8, R = i._bin, S = i.crc.crc, b = R.writeUint, x = R.writeUshort, m = R.writeASCII, k = i.encode.compressPNG(n, a, l, s, u);
          b(d, c, 13), c += 4, m(d, c, "IHDR"), c += 4, b(d, c, a), c += 4, b(d, c, l), c += 4, d[c] = k.depth, c++, d[c] = k.ctype, c++, d[c] = 0, c++, d[c] = 0, c++, d[c] = 0, c++, b(d, c, S(d, c - 17, 17)), c += 4, b(d, c, 1), c += 4, m(d, c, "sRGB"), c += 4, d[c] = 1, c++, b(d, c, S(d, c - 5, 5)), c += 4;
          var L = n.length > 1;
          if (L && (b(d, c, 8), c += 4, m(d, c, "acTL"), c += 4, b(d, c, n.length), c += 4, b(d, c, 0), c += 4, b(d, c, S(d, c - 12, 12)), c += 4), k.ctype == 3) {
            var z = k.plte.length;
            b(d, c, z * 3), c += 4, m(d, c, "PLTE"), c += 4;
            for (var v = 0; v < z; v++) {
              var E = v * 3, T = k.plte[v], I = T & 255, D = T >> 8 & 255, C = T >> 16 & 255;
              d[c + E + 0] = I, d[c + E + 1] = D, d[c + E + 2] = C;
            }
            if (c += z * 3, b(d, c, S(d, c - z * 3 - 4, z * 3 + 4)), c += 4, k.gotAlpha) {
              b(d, c, z), c += 4, m(d, c, "tRNS"), c += 4;
              for (var v = 0; v < z; v++) d[c + v] = k.plte[v] >> 24 & 255;
              c += z, b(d, c, S(d, c - z - 4, z + 4)), c += 4;
            }
          }
          for (var O = 0, N = 0; N < k.frames.length; N++) {
            var U = k.frames[N];
            L && (b(d, c, 26), c += 4, m(d, c, "fcTL"), c += 4, b(d, c, O++), c += 4, b(d, c, U.rect.width), c += 4, b(d, c, U.rect.height), c += 4, b(d, c, U.rect.x), c += 4, b(d, c, U.rect.y), c += 4, x(d, c, h[N]), c += 2, x(d, c, 1e3), c += 2, d[c] = U.dispose, c++, d[c] = U.blend, c++, b(d, c, S(d, c - 30, 30)), c += 4);
            var X = U.cimg, z = X.length;
            b(d, c, z + (N == 0 ? 0 : 4)), c += 4;
            var Y = c;
            m(d, c, N == 0 ? "IDAT" : "fdAT"), c += 4, N != 0 && (b(d, c, O++), c += 4);
            for (var v = 0; v < z; v++) d[c + v] = X[v];
            c += z, b(d, c, S(d, Y, c - Y)), c += 4;
          }
          return b(d, c, 0), c += 4, m(d, c, "IEND"), c += 4, b(d, c, S(d, c - 4, 4)), c += 4, d.buffer.slice(0, c);
        }, i.encode.compressPNG = function(n, a, l, s, h) {
          for (var u = i.encode.compress(n, a, l, s, !1, h), d = 0; d < n.length; d++) {
            var g = u.frames[d];
            g.rect.width;
            var v = g.rect.height, c = g.bpl, R = g.bpp, S = new Uint8Array(v * c + v);
            g.cimg = i.encode._filterZero(g.img, v, R, c, S);
          }
          return u;
        }, i.encode.compress = function(n, a, l, s, h, u) {
          u == null && (u = !1);
          for (var d = 6, g = 8, v = 4, c = 255, R = 0; R < n.length; R++)
            for (var S = new Uint8Array(n[R]), b = S.length, x = 0; x < b; x += 4) c &= S[x + 3];
          var m = c != 255, k = {}, L = [];
          if (n.length != 0 && (k[0] = 0, L.push(0), s != 0 && s--), s != 0) {
            var z = i.quantize(n, s, h);
            n = z.bufs;
            for (var x = 0; x < z.plte.length; x++) {
              var E = z.plte[x].est.rgba;
              k[E] == null && (k[E] = L.length, L.push(E));
            }
          } else
            for (var R = 0; R < n.length; R++)
              for (var T = new Uint32Array(n[R]), b = T.length, x = 0; x < b; x++) {
                var E = T[x];
                if ((x < a || E != T[x - 1] && E != T[x - a]) && k[E] == null && (k[E] = L.length, L.push(E), L.length >= 300))
                  break;
              }
          var I = m ? h : !1, D = L.length;
          D <= 256 && u == !1 && (D <= 2 ? g = 1 : D <= 4 ? g = 2 : D <= 16 ? g = 4 : g = 8, h && (g = 8), m = !0);
          for (var C = [], R = 0; R < n.length; R++) {
            var O = new Uint8Array(n[R]), N = new Uint32Array(O.buffer), U = 0, X = 0, Y = a, q = l, V = 0;
            if (R != 0 && !I) {
              for (var ne = h || R == 1 || C[C.length - 2].dispose == 2 ? 1 : 2, ve = 0, be = 1e9, de = 0; de < ne; de++) {
                for (var ze = new Uint8Array(n[R - 1 - de]), he = new Uint32Array(n[R - 1 - de]), ge = a, ue = l, re = -1, ie = -1, G = 0; G < l; G++) for (var W = 0; W < a; W++) {
                  var x = G * a + W;
                  N[x] != he[x] && (W < ge && (ge = W), W > re && (re = W), G < ue && (ue = G), G > ie && (ie = G));
                }
                var Ee = re == -1 ? 1 : (re - ge + 1) * (ie - ue + 1);
                Ee < be && (be = Ee, ve = de, re == -1 ? (U = X = 0, Y = q = 1) : (U = ge, X = ue, Y = re - ge + 1, q = ie - ue + 1));
              }
              var ze = new Uint8Array(n[R - 1 - ve]);
              ve == 1 && (C[C.length - 1].dispose = 2);
              var te = new Uint8Array(Y * q * 4);
              new Uint32Array(te.buffer), i._copyTile(ze, a, l, te, Y, q, -U, -X, 0), i._copyTile(O, a, l, te, Y, q, -U, -X, 3) ? (i._copyTile(O, a, l, te, Y, q, -U, -X, 2), V = 1) : (i._copyTile(O, a, l, te, Y, q, -U, -X, 0), V = 0), O = te, N = new Uint32Array(O.buffer);
            }
            var pe = 4 * Y;
            if (D <= 256 && u == !1) {
              pe = Math.ceil(g * Y / 8);
              for (var te = new Uint8Array(pe * q), G = 0; G < q; G++) {
                var x = G * pe, Ne = G * Y;
                if (g == 8) for (var W = 0; W < Y; W++) te[x + W] = k[N[Ne + W]];
                else if (g == 4) for (var W = 0; W < Y; W++) te[x + (W >> 1)] |= k[N[Ne + W]] << 4 - (W & 1) * 4;
                else if (g == 2) for (var W = 0; W < Y; W++) te[x + (W >> 2)] |= k[N[Ne + W]] << 6 - (W & 3) * 2;
                else if (g == 1) for (var W = 0; W < Y; W++) te[x + (W >> 3)] |= k[N[Ne + W]] << 7 - (W & 7) * 1;
              }
              O = te, d = 3, v = 1;
            } else if (m == !1 && n.length == 1) {
              for (var te = new Uint8Array(Y * q * 3), Ie = Y * q, x = 0; x < Ie; x++) {
                var ye = x * 3, ce = x * 4;
                te[ye] = O[ce], te[ye + 1] = O[ce + 1], te[ye + 2] = O[ce + 2];
              }
              O = te, d = 2, v = 3, pe = 3 * Y;
            }
            C.push({ rect: { x: U, y: X, width: Y, height: q }, img: O, bpl: pe, bpp: v, blend: V, dispose: I ? 1 : 0 });
          }
          return { ctype: d, depth: g, plte: L, gotAlpha: m, frames: C };
        }, i.encode._filterZero = function(n, a, l, s, h) {
          for (var u = [], d = 0; d < 5; d++)
            if (!(a * s > 5e5 && (d == 2 || d == 3 || d == 4))) {
              for (var g = 0; g < a; g++) i.encode._filterLine(h, n, g, s, l, d);
              if (u.push(f.deflate(h)), l == 1) break;
            }
          for (var v, c = 1e9, R = 0; R < u.length; R++) u[R].length < c && (v = R, c = u[R].length);
          return u[v];
        }, i.encode._filterLine = function(n, a, l, s, h, u) {
          var d = l * s, g = d + l, v = i.decode._paeth;
          if (n[g] = u, g++, u == 0) for (var c = 0; c < s; c++) n[g + c] = a[d + c];
          else if (u == 1) {
            for (var c = 0; c < h; c++) n[g + c] = a[d + c];
            for (var c = h; c < s; c++) n[g + c] = a[d + c] - a[d + c - h] + 256 & 255;
          } else if (l == 0) {
            for (var c = 0; c < h; c++) n[g + c] = a[d + c];
            if (u == 2) for (var c = h; c < s; c++) n[g + c] = a[d + c];
            if (u == 3) for (var c = h; c < s; c++) n[g + c] = a[d + c] - (a[d + c - h] >> 1) + 256 & 255;
            if (u == 4) for (var c = h; c < s; c++) n[g + c] = a[d + c] - v(a[d + c - h], 0, 0) + 256 & 255;
          } else {
            if (u == 2)
              for (var c = 0; c < s; c++) n[g + c] = a[d + c] + 256 - a[d + c - s] & 255;
            if (u == 3) {
              for (var c = 0; c < h; c++) n[g + c] = a[d + c] + 256 - (a[d + c - s] >> 1) & 255;
              for (var c = h; c < s; c++) n[g + c] = a[d + c] + 256 - (a[d + c - s] + a[d + c - h] >> 1) & 255;
            }
            if (u == 4) {
              for (var c = 0; c < h; c++) n[g + c] = a[d + c] + 256 - v(0, a[d + c - s], 0) & 255;
              for (var c = h; c < s; c++) n[g + c] = a[d + c] + 256 - v(a[d + c - h], a[d + c - s], a[d + c - h - s]) & 255;
            }
          }
        }, i.crc = {
          table: function() {
            for (var n = new Uint32Array(256), a = 0; a < 256; a++) {
              for (var l = a, s = 0; s < 8; s++)
                l & 1 ? l = 3988292384 ^ l >>> 1 : l = l >>> 1;
              n[a] = l;
            }
            return n;
          }(),
          update: function(n, a, l, s) {
            for (var h = 0; h < s; h++) n = i.crc.table[(n ^ a[l + h]) & 255] ^ n >>> 8;
            return n;
          },
          crc: function(n, a, l) {
            return i.crc.update(4294967295, n, a, l) ^ 4294967295;
          }
        }, i.quantize = function(n, a, l) {
          for (var s = [], h = 0, u = 0; u < n.length; u++)
            s.push(i.encode.alphaMul(new Uint8Array(n[u]), l)), h += n[u].byteLength;
          for (var d = new Uint8Array(h), g = new Uint32Array(d.buffer), v = 0, u = 0; u < s.length; u++) {
            for (var c = s[u], R = c.length, S = 0; S < R; S++) d[v + S] = c[S];
            v += R;
          }
          var b = { i0: 0, i1: d.length, bst: null, est: null, tdst: 0, left: null, right: null };
          b.bst = i.quantize.stats(d, b.i0, b.i1), b.est = i.quantize.estats(b.bst);
          for (var x = [b]; x.length < a; ) {
            for (var m = 0, k = 0, u = 0; u < x.length; u++) x[u].est.L > m && (m = x[u].est.L, k = u);
            if (m < 1e-3) break;
            var L = x[k], z = i.quantize.splitPixels(d, g, L.i0, L.i1, L.est.e, L.est.eMq255), E = { i0: L.i0, i1: z, bst: null, est: null, tdst: 0, left: null, right: null };
            E.bst = i.quantize.stats(d, E.i0, E.i1), E.est = i.quantize.estats(E.bst);
            var T = { i0: z, i1: L.i1, bst: null, est: null, tdst: 0, left: null, right: null };
            T.bst = { R: [], m: [], N: L.bst.N - E.bst.N };
            for (var u = 0; u < 16; u++) T.bst.R[u] = L.bst.R[u] - E.bst.R[u];
            for (var u = 0; u < 4; u++) T.bst.m[u] = L.bst.m[u] - E.bst.m[u];
            T.est = i.quantize.estats(T.bst), L.left = E, L.right = T, x[k] = E, x.push(T);
          }
          x.sort(function(ne, ve) {
            return ve.bst.N - ne.bst.N;
          });
          for (var I = 0; I < s.length; I++) {
            for (var D = i.quantize.planeDst, C = new Uint8Array(s[I].buffer), O = new Uint32Array(s[I].buffer), N = C.length, u = 0; u < N; u += 4) {
              for (var U = C[u] * 0.00392156862745098, X = C[u + 1] * (1 / 255), Y = C[u + 2] * (1 / 255), q = C[u + 3] * (1 / 255), V = b; V.left; ) V = D(V.est, U, X, Y, q) <= 0 ? V.left : V.right;
              O[u >> 2] = V.est.rgba;
            }
            s[I] = O.buffer;
          }
          return { bufs: s, plte: x };
        }, i.quantize.getNearest = function(n, a, l, s, h) {
          if (n.left == null)
            return n.tdst = i.quantize.dist(n.est.q, a, l, s, h), n;
          var u = i.quantize.planeDst(n.est, a, l, s, h), d = n.left, g = n.right;
          u > 0 && (d = n.right, g = n.left);
          var v = i.quantize.getNearest(d, a, l, s, h);
          if (v.tdst <= u * u) return v;
          var c = i.quantize.getNearest(g, a, l, s, h);
          return c.tdst < v.tdst ? c : v;
        }, i.quantize.planeDst = function(n, a, l, s, h) {
          var u = n.e;
          return u[0] * a + u[1] * l + u[2] * s + u[3] * h - n.eMq;
        }, i.quantize.dist = function(n, a, l, s, h) {
          var u = a - n[0], d = l - n[1], g = s - n[2], v = h - n[3];
          return u * u + d * d + g * g + v * v;
        }, i.quantize.splitPixels = function(n, a, l, s, h, u) {
          var d = i.quantize.vecDot;
          for (s -= 4; l < s; ) {
            for (; d(n, l, h) <= u; ) l += 4;
            for (; d(n, s, h) > u; ) s -= 4;
            if (l >= s) break;
            var g = a[l >> 2];
            a[l >> 2] = a[s >> 2], a[s >> 2] = g, l += 4, s -= 4;
          }
          for (; d(n, l, h) > u; ) l -= 4;
          return l + 4;
        }, i.quantize.vecDot = function(n, a, l) {
          return n[a] * l[0] + n[a + 1] * l[1] + n[a + 2] * l[2] + n[a + 3] * l[3];
        }, i.quantize.stats = function(n, a, l) {
          for (var s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], h = [0, 0, 0, 0], u = l - a >> 2, d = a; d < l; d += 4) {
            var g = n[d] * 0.00392156862745098, v = n[d + 1] * (1 / 255), c = n[d + 2] * (1 / 255), R = n[d + 3] * (1 / 255);
            h[0] += g, h[1] += v, h[2] += c, h[3] += R, s[0] += g * g, s[1] += g * v, s[2] += g * c, s[3] += g * R, s[5] += v * v, s[6] += v * c, s[7] += v * R, s[10] += c * c, s[11] += c * R, s[15] += R * R;
          }
          return s[4] = s[1], s[8] = s[2], s[12] = s[3], s[9] = s[6], s[13] = s[7], s[14] = s[11], { R: s, m: h, N: u };
        }, i.quantize.estats = function(n) {
          var a = n.R, l = n.m, s = n.N, h = l[0], u = l[1], d = l[2], g = l[3], v = s == 0 ? 0 : 1 / s, c = [
            a[0] - h * h * v,
            a[1] - h * u * v,
            a[2] - h * d * v,
            a[3] - h * g * v,
            a[4] - u * h * v,
            a[5] - u * u * v,
            a[6] - u * d * v,
            a[7] - u * g * v,
            a[8] - d * h * v,
            a[9] - d * u * v,
            a[10] - d * d * v,
            a[11] - d * g * v,
            a[12] - g * h * v,
            a[13] - g * u * v,
            a[14] - g * d * v,
            a[15] - g * g * v
          ], R = c, S = i.M4, b = [0.5, 0.5, 0.5, 0.5], x = 0, m = 0;
          if (s != 0)
            for (var k = 0; k < 10 && (b = S.multVec(R, b), m = Math.sqrt(S.dot(b, b)), b = S.sml(1 / m, b), !(Math.abs(m - x) < 1e-9)); k++)
              x = m;
          var L = [h * v, u * v, d * v, g * v], z = S.dot(S.sml(255, L), b), E = L[3] < 1e-3 ? 0 : 1 / L[3];
          return {
            Cov: c,
            q: L,
            e: b,
            L: x,
            eMq255: z,
            eMq: S.dot(b, L),
            rgba: (Math.round(255 * L[3]) << 24 | Math.round(255 * L[2] * E) << 16 | Math.round(255 * L[1] * E) << 8 | Math.round(255 * L[0] * E) << 0) >>> 0
          };
        }, i.M4 = {
          multVec: function(n, a) {
            return [
              n[0] * a[0] + n[1] * a[1] + n[2] * a[2] + n[3] * a[3],
              n[4] * a[0] + n[5] * a[1] + n[6] * a[2] + n[7] * a[3],
              n[8] * a[0] + n[9] * a[1] + n[10] * a[2] + n[11] * a[3],
              n[12] * a[0] + n[13] * a[1] + n[14] * a[2] + n[15] * a[3]
            ];
          },
          dot: function(n, a) {
            return n[0] * a[0] + n[1] * a[1] + n[2] * a[2] + n[3] * a[3];
          },
          sml: function(n, a) {
            return [n * a[0], n * a[1], n * a[2], n * a[3]];
          }
        }, i.encode.alphaMul = function(n, a) {
          for (var l = new Uint8Array(n.length), s = n.length >> 2, h = 0; h < s; h++) {
            var u = h << 2, d = n[u + 3];
            a && (d = d < 128 ? 0 : 255);
            var g = d * (1 / 255);
            l[u + 0] = n[u + 0] * g, l[u + 1] = n[u + 1] * g, l[u + 2] = n[u + 2] * g, l[u + 3] = d;
          }
          return l;
        };
      }(r, t);
    })();
  }(Qn)), Qn.exports;
}
var nf = tf();
const Li = /* @__PURE__ */ Aa(nf), rf = 8, af = {
  H: "HEX",
  Z: "Zlib compressed",
  2: "Base32"
}, of = new Set(Object.keys(af)), ff = {
  H: 2,
  Z: 8,
  2: 8
}, Ma = {
  1: {
    L: { 0: 152, 1: 41, 2: 25, 4: 17, 8: 10 },
    M: { 0: 128, 1: 34, 2: 20, 4: 14, 8: 8 },
    Q: { 0: 104, 1: 27, 2: 16, 4: 11, 8: 7 },
    H: { 0: 72, 1: 17, 2: 10, 4: 7, 8: 4 }
  },
  2: {
    L: { 0: 272, 1: 77, 2: 47, 4: 32, 8: 20 },
    M: { 0: 224, 1: 63, 2: 38, 4: 26, 8: 16 },
    Q: { 0: 176, 1: 48, 2: 29, 4: 20, 8: 12 },
    H: { 0: 128, 1: 34, 2: 20, 4: 14, 8: 8 }
  },
  3: {
    L: { 0: 440, 1: 127, 2: 77, 4: 53, 8: 32 },
    M: { 0: 352, 1: 101, 2: 61, 4: 42, 8: 26 },
    Q: { 0: 272, 1: 77, 2: 47, 4: 32, 8: 20 },
    H: { 0: 208, 1: 58, 2: 35, 4: 24, 8: 15 }
  },
  4: {
    L: { 0: 640, 1: 187, 2: 114, 4: 78, 8: 48 },
    M: { 0: 512, 1: 149, 2: 90, 4: 62, 8: 38 },
    Q: { 0: 384, 1: 111, 2: 67, 4: 46, 8: 28 },
    H: { 0: 288, 1: 82, 2: 50, 4: 34, 8: 21 }
  },
  5: {
    L: { 0: 864, 1: 255, 2: 154, 4: 106, 8: 65 },
    M: { 0: 688, 1: 202, 2: 122, 4: 84, 8: 52 },
    Q: { 0: 496, 1: 144, 2: 87, 4: 60, 8: 37 },
    H: { 0: 368, 1: 106, 2: 64, 4: 44, 8: 27 }
  },
  6: {
    L: { 0: 1088, 1: 322, 2: 195, 4: 134, 8: 82 },
    M: { 0: 864, 1: 255, 2: 154, 4: 106, 8: 65 },
    Q: { 0: 608, 1: 178, 2: 108, 4: 74, 8: 45 },
    H: { 0: 480, 1: 139, 2: 84, 4: 58, 8: 36 }
  },
  7: {
    L: { 0: 1248, 1: 370, 2: 224, 4: 154, 8: 95 },
    M: { 0: 992, 1: 293, 2: 178, 4: 122, 8: 75 },
    Q: { 0: 704, 1: 207, 2: 125, 4: 86, 8: 53 },
    H: { 0: 528, 1: 154, 2: 93, 4: 64, 8: 39 }
  },
  8: {
    L: { 0: 1552, 1: 461, 2: 279, 4: 192, 8: 118 },
    M: { 0: 1232, 1: 365, 2: 221, 4: 152, 8: 93 },
    Q: { 0: 880, 1: 259, 2: 157, 4: 108, 8: 66 },
    H: { 0: 688, 1: 202, 2: 122, 4: 84, 8: 52 }
  },
  9: {
    L: { 0: 1856, 1: 552, 2: 335, 4: 230, 8: 141 },
    M: { 0: 1456, 1: 432, 2: 262, 4: 180, 8: 111 },
    Q: { 0: 1056, 1: 312, 2: 189, 4: 130, 8: 80 },
    H: { 0: 800, 1: 235, 2: 143, 4: 98, 8: 60 }
  },
  10: {
    L: { 0: 2192, 1: 652, 2: 395, 4: 271, 8: 167 },
    M: { 0: 1728, 1: 513, 2: 311, 4: 213, 8: 131 },
    Q: { 0: 1232, 1: 364, 2: 221, 4: 151, 8: 93 },
    H: { 0: 976, 1: 288, 2: 174, 4: 119, 8: 74 }
  },
  11: {
    L: { 0: 2592, 1: 772, 2: 468, 4: 321, 8: 198 },
    M: { 0: 2032, 1: 604, 2: 366, 4: 251, 8: 155 },
    Q: { 0: 1440, 1: 427, 2: 259, 4: 177, 8: 109 },
    H: { 0: 1120, 1: 331, 2: 200, 4: 137, 8: 85 }
  },
  12: {
    L: { 0: 2960, 1: 883, 2: 535, 4: 367, 8: 226 },
    M: { 0: 2320, 1: 691, 2: 419, 4: 287, 8: 177 },
    Q: { 0: 1648, 1: 489, 2: 296, 4: 203, 8: 125 },
    H: { 0: 1264, 1: 374, 2: 227, 4: 155, 8: 96 }
  },
  13: {
    L: { 0: 3424, 1: 1022, 2: 619, 4: 425, 8: 262 },
    M: { 0: 2672, 1: 796, 2: 483, 4: 331, 8: 204 },
    Q: { 0: 1952, 1: 580, 2: 352, 4: 241, 8: 149 },
    H: { 0: 1440, 1: 427, 2: 259, 4: 177, 8: 109 }
  },
  14: {
    L: { 0: 3688, 1: 1101, 2: 667, 4: 458, 8: 282 },
    M: { 0: 2920, 1: 871, 2: 528, 4: 362, 8: 223 },
    Q: { 0: 2088, 1: 621, 2: 376, 4: 258, 8: 159 },
    H: { 0: 1576, 1: 468, 2: 283, 4: 194, 8: 120 }
  },
  15: {
    L: { 0: 4184, 1: 1250, 2: 758, 4: 520, 8: 320 },
    M: { 0: 3320, 1: 991, 2: 600, 4: 412, 8: 254 },
    Q: { 0: 2360, 1: 703, 2: 426, 4: 292, 8: 180 },
    H: { 0: 1784, 1: 530, 2: 321, 4: 220, 8: 136 }
  },
  16: {
    L: { 0: 4712, 1: 1408, 2: 854, 4: 586, 8: 361 },
    M: { 0: 3624, 1: 1082, 2: 656, 4: 450, 8: 277 },
    Q: { 0: 2600, 1: 775, 2: 470, 4: 322, 8: 198 },
    H: { 0: 2024, 1: 602, 2: 365, 4: 250, 8: 154 }
  },
  17: {
    L: { 0: 5176, 1: 1548, 2: 938, 4: 644, 8: 397 },
    M: { 0: 4056, 1: 1212, 2: 734, 4: 504, 8: 310 },
    Q: { 0: 2936, 1: 876, 2: 531, 4: 364, 8: 224 },
    H: { 0: 2264, 1: 674, 2: 408, 4: 280, 8: 173 }
  },
  18: {
    L: { 0: 5768, 1: 1725, 2: 1046, 4: 718, 8: 442 },
    M: { 0: 4504, 1: 1346, 2: 816, 4: 560, 8: 345 },
    Q: { 0: 3176, 1: 948, 2: 574, 4: 394, 8: 243 },
    H: { 0: 2504, 1: 746, 2: 452, 4: 310, 8: 191 }
  },
  19: {
    L: { 0: 6360, 1: 1903, 2: 1153, 4: 792, 8: 488 },
    M: { 0: 5016, 1: 1500, 2: 909, 4: 624, 8: 384 },
    Q: { 0: 3560, 1: 1063, 2: 644, 4: 442, 8: 272 },
    H: { 0: 2728, 1: 813, 2: 493, 4: 338, 8: 208 }
  },
  20: {
    L: { 0: 6888, 1: 2061, 2: 1249, 4: 858, 8: 528 },
    M: { 0: 5352, 1: 1600, 2: 970, 4: 666, 8: 410 },
    Q: { 0: 3880, 1: 1159, 2: 702, 4: 482, 8: 297 },
    H: { 0: 3080, 1: 919, 2: 557, 4: 382, 8: 235 }
  },
  21: {
    L: { 0: 7456, 1: 2232, 2: 1352, 4: 929, 8: 572 },
    M: { 0: 5712, 1: 1708, 2: 1035, 4: 711, 8: 438 },
    Q: { 0: 4096, 1: 1224, 2: 742, 4: 509, 8: 314 },
    H: { 0: 3248, 1: 969, 2: 587, 4: 403, 8: 248 }
  },
  22: {
    L: { 0: 8048, 1: 2409, 2: 1460, 4: 1003, 8: 618 },
    M: { 0: 6256, 1: 1872, 2: 1134, 4: 779, 8: 480 },
    Q: { 0: 4544, 1: 1358, 2: 823, 4: 565, 8: 348 },
    H: { 0: 3536, 1: 1056, 2: 640, 4: 439, 8: 270 }
  },
  23: {
    L: { 0: 8752, 1: 2620, 2: 1588, 4: 1091, 8: 672 },
    M: { 0: 6880, 1: 2059, 2: 1248, 4: 857, 8: 528 },
    Q: { 0: 4912, 1: 1468, 2: 890, 4: 611, 8: 376 },
    H: { 0: 3712, 1: 1108, 2: 672, 4: 461, 8: 284 }
  },
  24: {
    L: { 0: 9392, 1: 2812, 2: 1704, 4: 1171, 8: 721 },
    M: { 0: 7312, 1: 2188, 2: 1326, 4: 911, 8: 561 },
    Q: { 0: 5312, 1: 1588, 2: 963, 4: 661, 8: 407 },
    H: { 0: 4112, 1: 1228, 2: 744, 4: 511, 8: 315 }
  },
  25: {
    L: { 0: 10208, 1: 3057, 2: 1853, 4: 1273, 8: 784 },
    M: { 0: 8e3, 1: 2395, 2: 1451, 4: 997, 8: 614 },
    Q: { 0: 5744, 1: 1718, 2: 1041, 4: 715, 8: 440 },
    H: { 0: 4304, 1: 1286, 2: 779, 4: 535, 8: 330 }
  },
  26: {
    L: { 0: 10960, 1: 3283, 2: 1990, 4: 1367, 8: 842 },
    M: { 0: 8496, 1: 2544, 2: 1542, 4: 1059, 8: 652 },
    Q: { 0: 6032, 1: 1804, 2: 1094, 4: 751, 8: 462 },
    H: { 0: 4768, 1: 1425, 2: 864, 4: 593, 8: 365 }
  },
  27: {
    L: { 0: 11744, 1: 3514, 2: 2132, 4: 1465, 8: 902 },
    M: { 0: 9024, 1: 2701, 2: 1637, 4: 1125, 8: 692 },
    Q: { 0: 6464, 1: 1933, 2: 1172, 4: 805, 8: 496 },
    H: { 0: 5024, 1: 1501, 2: 910, 4: 625, 8: 385 }
  },
  28: {
    L: { 0: 12248, 1: 3669, 2: 2223, 4: 1528, 8: 940 },
    M: { 0: 9544, 1: 2857, 2: 1732, 4: 1190, 8: 732 },
    Q: { 0: 6968, 1: 2085, 2: 1263, 4: 868, 8: 534 },
    H: { 0: 5288, 1: 1581, 2: 958, 4: 658, 8: 405 }
  },
  29: {
    L: { 0: 13048, 1: 3909, 2: 2369, 4: 1628, 8: 1002 },
    M: { 0: 10136, 1: 3035, 2: 1839, 4: 1264, 8: 778 },
    Q: { 0: 7288, 1: 2181, 2: 1322, 4: 908, 8: 559 },
    H: { 0: 5608, 1: 1677, 2: 1016, 4: 698, 8: 430 }
  },
  30: {
    L: { 0: 13880, 1: 4158, 2: 2520, 4: 1732, 8: 1066 },
    M: { 0: 10984, 1: 3289, 2: 1994, 4: 1370, 8: 843 },
    Q: { 0: 7880, 1: 2358, 2: 1429, 4: 982, 8: 604 },
    H: { 0: 5960, 1: 1782, 2: 1080, 4: 742, 8: 457 }
  },
  31: {
    L: { 0: 14744, 1: 4417, 2: 2677, 4: 1840, 8: 1132 },
    M: { 0: 11640, 1: 3486, 2: 2113, 4: 1452, 8: 894 },
    Q: { 0: 8264, 1: 2473, 2: 1499, 4: 1030, 8: 634 },
    H: { 0: 6344, 1: 1897, 2: 1150, 4: 790, 8: 486 }
  },
  32: {
    L: { 0: 15640, 1: 4686, 2: 2840, 4: 1952, 8: 1201 },
    M: { 0: 12328, 1: 3693, 2: 2238, 4: 1538, 8: 947 },
    Q: { 0: 8920, 1: 2670, 2: 1618, 4: 1112, 8: 684 },
    H: { 0: 6760, 1: 2022, 2: 1226, 4: 842, 8: 518 }
  },
  33: {
    L: { 0: 16568, 1: 4965, 2: 3009, 4: 2068, 8: 1273 },
    M: { 0: 13048, 1: 3909, 2: 2369, 4: 1628, 8: 1002 },
    Q: { 0: 9368, 1: 2805, 2: 1700, 4: 1168, 8: 719 },
    H: { 0: 7208, 1: 2157, 2: 1307, 4: 898, 8: 553 }
  },
  34: {
    L: { 0: 17528, 1: 5253, 2: 3183, 4: 2188, 8: 1347 },
    M: { 0: 13800, 1: 4134, 2: 2506, 4: 1722, 8: 1060 },
    Q: { 0: 9848, 1: 2949, 2: 1787, 4: 1228, 8: 756 },
    H: { 0: 7688, 1: 2301, 2: 1394, 4: 958, 8: 590 }
  },
  35: {
    L: { 0: 18448, 1: 5529, 2: 3351, 4: 2303, 8: 1417 },
    M: { 0: 14496, 1: 4343, 2: 2632, 4: 1809, 8: 1113 },
    Q: { 0: 10288, 1: 3081, 2: 1867, 4: 1283, 8: 790 },
    H: { 0: 7888, 1: 2361, 2: 1431, 4: 983, 8: 605 }
  },
  36: {
    L: { 0: 19472, 1: 5836, 2: 3537, 4: 2431, 8: 1496 },
    M: { 0: 15312, 1: 4588, 2: 2780, 4: 1911, 8: 1176 },
    Q: { 0: 10832, 1: 3244, 2: 1966, 4: 1351, 8: 832 },
    H: { 0: 8432, 1: 2524, 2: 1530, 4: 1051, 8: 647 }
  },
  37: {
    L: { 0: 20528, 1: 6153, 2: 3729, 4: 2563, 8: 1577 },
    M: { 0: 15936, 1: 4775, 2: 2894, 4: 1989, 8: 1224 },
    Q: { 0: 11408, 1: 3417, 2: 2071, 4: 1423, 8: 876 },
    H: { 0: 8768, 1: 2625, 2: 1591, 4: 1093, 8: 673 }
  },
  38: {
    L: { 0: 21616, 1: 6479, 2: 3927, 4: 2699, 8: 1661 },
    M: { 0: 16816, 1: 5039, 2: 3054, 4: 2099, 8: 1292 },
    Q: { 0: 12016, 1: 3599, 2: 2181, 4: 1499, 8: 923 },
    H: { 0: 9136, 1: 2735, 2: 1658, 4: 1139, 8: 701 }
  },
  39: {
    L: { 0: 22496, 1: 6743, 2: 4087, 4: 2809, 8: 1729 },
    M: { 0: 17728, 1: 5313, 2: 3220, 4: 2213, 8: 1362 },
    Q: { 0: 12656, 1: 3791, 2: 2298, 4: 1579, 8: 972 },
    H: { 0: 9776, 1: 2927, 2: 1774, 4: 1219, 8: 750 }
  },
  40: {
    L: { 0: 23648, 1: 7089, 2: 4296, 4: 2953, 8: 1817 },
    M: { 0: 18672, 1: 5596, 2: 3391, 4: 2331, 8: 1435 },
    Q: { 0: 13328, 1: 3993, 2: 2420, 4: 1663, 8: 1024 },
    H: { 0: 10208, 1: 3057, 2: 1852, 4: 1273, 8: 784 }
  }
}, lf = {
  1: 21,
  2: 25,
  3: 29,
  4: 33,
  5: 37,
  6: 41,
  7: 45,
  8: 49,
  9: 53,
  10: 57,
  11: 61,
  12: 65,
  13: 69,
  14: 73,
  15: 77,
  16: 81,
  17: 85,
  18: 89,
  19: 93,
  20: 97,
  21: 101,
  22: 105,
  23: 109,
  24: 113,
  25: 117,
  26: 121,
  27: 125,
  28: 129,
  29: 133,
  30: 137,
  31: 141,
  32: 145,
  33: 149,
  34: 153,
  35: 157,
  36: 161,
  37: 165,
  38: 169,
  39: 173,
  40: 177
};
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function sf(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Na(e, r) {
  return Array.isArray(r) ? r.length === 0 ? !0 : e ? r.every((t) => typeof t == "string") : r.every((t) => Number.isSafeInteger(t)) : !1;
}
function gn(e, r) {
  if (typeof r != "string")
    throw new Error(`${e}: string expected`);
  return !0;
}
function Lr(e) {
  if (!Number.isSafeInteger(e))
    throw new Error(`invalid integer: ${e}`);
}
function pr(e) {
  if (!Array.isArray(e))
    throw new Error("array expected");
}
function vn(e, r) {
  if (!Na(!0, r))
    throw new Error(`${e}: array of strings expected`);
}
function hf(e, r) {
  if (!Na(!1, r))
    throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function uf(...e) {
  const r = (n) => n, t = (n, a) => (l) => n(a(l)), i = e.map((n) => n.encode).reduceRight(t, r), f = e.map((n) => n.decode).reduce(t, r);
  return { encode: i, decode: f };
}
// @__NO_SIDE_EFFECTS__
function cf(e) {
  const r = typeof e == "string" ? e.split("") : e, t = r.length;
  vn("alphabet", r);
  const i = new Map(r.map((f, n) => [f, n]));
  return {
    encode: (f) => (pr(f), f.map((n) => {
      if (!Number.isSafeInteger(n) || n < 0 || n >= t)
        throw new Error(`alphabet.encode: digit index outside alphabet "${n}". Allowed: ${e}`);
      return r[n];
    })),
    decode: (f) => (pr(f), f.map((n) => {
      gn("alphabet.decode", n);
      const a = i.get(n);
      if (a === void 0)
        throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);
      return a;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function df(e = "") {
  return gn("join", e), {
    encode: (r) => (vn("join.decode", r), r.join(e)),
    decode: (r) => (gn("join.decode", r), r.split(e))
  };
}
// @__NO_SIDE_EFFECTS__
function _f(e, r = "=") {
  return Lr(e), gn("padding", r), {
    encode(t) {
      for (vn("padding.encode", t); t.length * e % 8; )
        t.push(r);
      return t;
    },
    decode(t) {
      vn("padding.decode", t);
      let i = t.length;
      if (i * e % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; i > 0 && t[i - 1] === r; i--)
        if ((i - 1) * e % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return t.slice(0, i);
    }
  };
}
const Za = (e, r) => r === 0 ? e : Za(r, e % r), wn = /* @__NO_SIDE_EFFECTS__ */ (e, r) => e + (r - Za(e, r)), ir = /* @__PURE__ */ (() => {
  let e = [];
  for (let r = 0; r < 40; r++)
    e.push(2 ** r);
  return e;
})();
function Bi(e, r, t, i) {
  if (pr(e), r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong from=${r}`);
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong to=${t}`);
  if (/* @__PURE__ */ wn(r, t) > 32)
    throw new Error(`convertRadix2: carry overflow from=${r} to=${t} carryBits=${/* @__PURE__ */ wn(r, t)}`);
  let f = 0, n = 0;
  const a = ir[r], l = ir[t] - 1, s = [];
  for (const h of e) {
    if (Lr(h), h >= a)
      throw new Error(`convertRadix2: invalid data word=${h} from=${r}`);
    if (f = f << r | h, n + r > 32)
      throw new Error(`convertRadix2: carry overflow pos=${n} from=${r}`);
    for (n += r; n >= t; n -= t)
      s.push((f >> n - t & l) >>> 0);
    const u = ir[n];
    if (u === void 0)
      throw new Error("invalid carry");
    f &= u - 1;
  }
  if (f = f << t - n & l, !i && n >= r)
    throw new Error("Excess padding");
  if (!i && f > 0)
    throw new Error(`Non-zero padding: ${f}`);
  return i && n > 0 && s.push(f >>> 0), s;
}
// @__NO_SIDE_EFFECTS__
function gf(e, r = !1) {
  if (Lr(e), e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ wn(8, e) > 32 || /* @__PURE__ */ wn(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (t) => {
      if (!sf(t))
        throw new Error("radix2.encode input should be Uint8Array");
      return Bi(Array.from(t), 8, e, !r);
    },
    decode: (t) => (hf("radix2.decode", t), Uint8Array.from(Bi(t, e, 8, r)))
  };
}
const Oa = /* @__PURE__ */ uf(/* @__PURE__ */ gf(5), /* @__PURE__ */ cf("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ _f(5), /* @__PURE__ */ df(""));
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const vf = 4, Mi = 0, Ni = 1, wf = 2;
function Nt(e) {
  let r = e.length;
  for (; --r >= 0; )
    e[r] = 0;
}
const bf = 0, Ha = 1, pf = 2, xf = 3, Ef = 258, Br = 29, en = 256, Yt = en + 1 + Br, Lt = 30, Mr = 19, Ua = 2 * Yt + 1, gt = 15, ar = 16, kf = 7, Nr = 256, Fa = 16, $a = 17, Pa = 18, xr = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), _n = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), mf = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), qa = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), yf = 512, tt = new Array((Yt + 2) * 2);
Nt(tt);
const Pt = new Array(Lt * 2);
Nt(Pt);
const Qt = new Array(yf);
Nt(Qt);
const Vt = new Array(Ef - xf + 1);
Nt(Vt);
const Zr = new Array(Br);
Nt(Zr);
const bn = new Array(Lt);
Nt(bn);
function or(e, r, t, i, f) {
  this.static_tree = e, this.extra_bits = r, this.extra_base = t, this.elems = i, this.max_length = f, this.has_stree = e && e.length;
}
let Ka, Ya, Qa;
function fr(e, r) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = r;
}
const Va = (e) => e < 256 ? Qt[e] : Qt[256 + (e >>> 7)], jt = (e, r) => {
  e.pending_buf[e.pending++] = r & 255, e.pending_buf[e.pending++] = r >>> 8 & 255;
}, Le = (e, r, t) => {
  e.bi_valid > ar - t ? (e.bi_buf |= r << e.bi_valid & 65535, jt(e, e.bi_buf), e.bi_buf = r >> ar - e.bi_valid, e.bi_valid += t - ar) : (e.bi_buf |= r << e.bi_valid & 65535, e.bi_valid += t);
}, je = (e, r, t) => {
  Le(
    e,
    t[r * 2],
    t[r * 2 + 1]
    /*.Len*/
  );
}, ja = (e, r) => {
  let t = 0;
  do
    t |= e & 1, e >>>= 1, t <<= 1;
  while (--r > 0);
  return t >>> 1;
}, Af = (e) => {
  e.bi_valid === 16 ? (jt(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, Sf = (e, r) => {
  const t = r.dyn_tree, i = r.max_code, f = r.stat_desc.static_tree, n = r.stat_desc.has_stree, a = r.stat_desc.extra_bits, l = r.stat_desc.extra_base, s = r.stat_desc.max_length;
  let h, u, d, g, v, c, R = 0;
  for (g = 0; g <= gt; g++)
    e.bl_count[g] = 0;
  for (t[e.heap[e.heap_max] * 2 + 1] = 0, h = e.heap_max + 1; h < Ua; h++)
    u = e.heap[h], g = t[t[u * 2 + 1] * 2 + 1] + 1, g > s && (g = s, R++), t[u * 2 + 1] = g, !(u > i) && (e.bl_count[g]++, v = 0, u >= l && (v = a[u - l]), c = t[u * 2], e.opt_len += c * (g + v), n && (e.static_len += c * (f[u * 2 + 1] + v)));
  if (R !== 0) {
    do {
      for (g = s - 1; e.bl_count[g] === 0; )
        g--;
      e.bl_count[g]--, e.bl_count[g + 1] += 2, e.bl_count[s]--, R -= 2;
    } while (R > 0);
    for (g = s; g !== 0; g--)
      for (u = e.bl_count[g]; u !== 0; )
        d = e.heap[--h], !(d > i) && (t[d * 2 + 1] !== g && (e.opt_len += (g - t[d * 2 + 1]) * t[d * 2], t[d * 2 + 1] = g), u--);
  }
}, Xa = (e, r, t) => {
  const i = new Array(gt + 1);
  let f = 0, n, a;
  for (n = 1; n <= gt; n++)
    f = f + t[n - 1] << 1, i[n] = f;
  for (a = 0; a <= r; a++) {
    let l = e[a * 2 + 1];
    l !== 0 && (e[a * 2] = ja(i[l]++, l));
  }
}, Rf = () => {
  let e, r, t, i, f;
  const n = new Array(gt + 1);
  for (t = 0, i = 0; i < Br - 1; i++)
    for (Zr[i] = t, e = 0; e < 1 << xr[i]; e++)
      Vt[t++] = i;
  for (Vt[t - 1] = i, f = 0, i = 0; i < 16; i++)
    for (bn[i] = f, e = 0; e < 1 << _n[i]; e++)
      Qt[f++] = i;
  for (f >>= 7; i < Lt; i++)
    for (bn[i] = f << 7, e = 0; e < 1 << _n[i] - 7; e++)
      Qt[256 + f++] = i;
  for (r = 0; r <= gt; r++)
    n[r] = 0;
  for (e = 0; e <= 143; )
    tt[e * 2 + 1] = 8, e++, n[8]++;
  for (; e <= 255; )
    tt[e * 2 + 1] = 9, e++, n[9]++;
  for (; e <= 279; )
    tt[e * 2 + 1] = 7, e++, n[7]++;
  for (; e <= 287; )
    tt[e * 2 + 1] = 8, e++, n[8]++;
  for (Xa(tt, Yt + 1, n), e = 0; e < Lt; e++)
    Pt[e * 2 + 1] = 5, Pt[e * 2] = ja(e, 5);
  Ka = new or(tt, xr, en + 1, Yt, gt), Ya = new or(Pt, _n, 0, Lt, gt), Qa = new or(new Array(0), mf, 0, Mr, kf);
}, Ja = (e) => {
  let r;
  for (r = 0; r < Yt; r++)
    e.dyn_ltree[r * 2] = 0;
  for (r = 0; r < Lt; r++)
    e.dyn_dtree[r * 2] = 0;
  for (r = 0; r < Mr; r++)
    e.bl_tree[r * 2] = 0;
  e.dyn_ltree[Nr * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, Wa = (e) => {
  e.bi_valid > 8 ? jt(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Zi = (e, r, t, i) => {
  const f = r * 2, n = t * 2;
  return e[f] < e[n] || e[f] === e[n] && i[r] <= i[t];
}, lr = (e, r, t) => {
  const i = e.heap[t];
  let f = t << 1;
  for (; f <= e.heap_len && (f < e.heap_len && Zi(r, e.heap[f + 1], e.heap[f], e.depth) && f++, !Zi(r, i, e.heap[f], e.depth)); )
    e.heap[t] = e.heap[f], t = f, f <<= 1;
  e.heap[t] = i;
}, Oi = (e, r, t) => {
  let i, f, n = 0, a, l;
  if (e.sym_next !== 0)
    do
      i = e.pending_buf[e.sym_buf + n++] & 255, i += (e.pending_buf[e.sym_buf + n++] & 255) << 8, f = e.pending_buf[e.sym_buf + n++], i === 0 ? je(e, f, r) : (a = Vt[f], je(e, a + en + 1, r), l = xr[a], l !== 0 && (f -= Zr[a], Le(e, f, l)), i--, a = Va(i), je(e, a, t), l = _n[a], l !== 0 && (i -= bn[a], Le(e, i, l)));
    while (n < e.sym_next);
  je(e, Nr, r);
}, Er = (e, r) => {
  const t = r.dyn_tree, i = r.stat_desc.static_tree, f = r.stat_desc.has_stree, n = r.stat_desc.elems;
  let a, l, s = -1, h;
  for (e.heap_len = 0, e.heap_max = Ua, a = 0; a < n; a++)
    t[a * 2] !== 0 ? (e.heap[++e.heap_len] = s = a, e.depth[a] = 0) : t[a * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    h = e.heap[++e.heap_len] = s < 2 ? ++s : 0, t[h * 2] = 1, e.depth[h] = 0, e.opt_len--, f && (e.static_len -= i[h * 2 + 1]);
  for (r.max_code = s, a = e.heap_len >> 1; a >= 1; a--)
    lr(e, t, a);
  h = n;
  do
    a = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], lr(
      e,
      t,
      1
      /*SMALLEST*/
    ), l = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = a, e.heap[--e.heap_max] = l, t[h * 2] = t[a * 2] + t[l * 2], e.depth[h] = (e.depth[a] >= e.depth[l] ? e.depth[a] : e.depth[l]) + 1, t[a * 2 + 1] = t[l * 2 + 1] = h, e.heap[
      1
      /*SMALLEST*/
    ] = h++, lr(
      e,
      t,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], Sf(e, r), Xa(t, s, e.bl_count);
}, Hi = (e, r, t) => {
  let i, f = -1, n, a = r[0 * 2 + 1], l = 0, s = 7, h = 4;
  for (a === 0 && (s = 138, h = 3), r[(t + 1) * 2 + 1] = 65535, i = 0; i <= t; i++)
    n = a, a = r[(i + 1) * 2 + 1], !(++l < s && n === a) && (l < h ? e.bl_tree[n * 2] += l : n !== 0 ? (n !== f && e.bl_tree[n * 2]++, e.bl_tree[Fa * 2]++) : l <= 10 ? e.bl_tree[$a * 2]++ : e.bl_tree[Pa * 2]++, l = 0, f = n, a === 0 ? (s = 138, h = 3) : n === a ? (s = 6, h = 3) : (s = 7, h = 4));
}, Ui = (e, r, t) => {
  let i, f = -1, n, a = r[0 * 2 + 1], l = 0, s = 7, h = 4;
  for (a === 0 && (s = 138, h = 3), i = 0; i <= t; i++)
    if (n = a, a = r[(i + 1) * 2 + 1], !(++l < s && n === a)) {
      if (l < h)
        do
          je(e, n, e.bl_tree);
        while (--l !== 0);
      else n !== 0 ? (n !== f && (je(e, n, e.bl_tree), l--), je(e, Fa, e.bl_tree), Le(e, l - 3, 2)) : l <= 10 ? (je(e, $a, e.bl_tree), Le(e, l - 3, 3)) : (je(e, Pa, e.bl_tree), Le(e, l - 11, 7));
      l = 0, f = n, a === 0 ? (s = 138, h = 3) : n === a ? (s = 6, h = 3) : (s = 7, h = 4);
    }
}, Tf = (e) => {
  let r;
  for (Hi(e, e.dyn_ltree, e.l_desc.max_code), Hi(e, e.dyn_dtree, e.d_desc.max_code), Er(e, e.bl_desc), r = Mr - 1; r >= 3 && e.bl_tree[qa[r] * 2 + 1] === 0; r--)
    ;
  return e.opt_len += 3 * (r + 1) + 5 + 5 + 4, r;
}, zf = (e, r, t, i) => {
  let f;
  for (Le(e, r - 257, 5), Le(e, t - 1, 5), Le(e, i - 4, 4), f = 0; f < i; f++)
    Le(e, e.bl_tree[qa[f] * 2 + 1], 3);
  Ui(e, e.dyn_ltree, r - 1), Ui(e, e.dyn_dtree, t - 1);
}, Cf = (e) => {
  let r = 4093624447, t;
  for (t = 0; t <= 31; t++, r >>>= 1)
    if (r & 1 && e.dyn_ltree[t * 2] !== 0)
      return Mi;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Ni;
  for (t = 32; t < en; t++)
    if (e.dyn_ltree[t * 2] !== 0)
      return Ni;
  return Mi;
};
let Fi = !1;
const If = (e) => {
  Fi || (Rf(), Fi = !0), e.l_desc = new fr(e.dyn_ltree, Ka), e.d_desc = new fr(e.dyn_dtree, Ya), e.bl_desc = new fr(e.bl_tree, Qa), e.bi_buf = 0, e.bi_valid = 0, Ja(e);
}, Ga = (e, r, t, i) => {
  Le(e, (bf << 1) + (i ? 1 : 0), 3), Wa(e), jt(e, t), jt(e, ~t), t && e.pending_buf.set(e.window.subarray(r, r + t), e.pending), e.pending += t;
}, Df = (e) => {
  Le(e, Ha << 1, 3), je(e, Nr, tt), Af(e);
}, Lf = (e, r, t, i) => {
  let f, n, a = 0;
  e.level > 0 ? (e.strm.data_type === wf && (e.strm.data_type = Cf(e)), Er(e, e.l_desc), Er(e, e.d_desc), a = Tf(e), f = e.opt_len + 3 + 7 >>> 3, n = e.static_len + 3 + 7 >>> 3, n <= f && (f = n)) : f = n = t + 5, t + 4 <= f && r !== -1 ? Ga(e, r, t, i) : e.strategy === vf || n === f ? (Le(e, (Ha << 1) + (i ? 1 : 0), 3), Oi(e, tt, Pt)) : (Le(e, (pf << 1) + (i ? 1 : 0), 3), zf(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), Oi(e, e.dyn_ltree, e.dyn_dtree)), Ja(e), i && Wa(e);
}, Bf = (e, r, t) => (e.pending_buf[e.sym_buf + e.sym_next++] = r, e.pending_buf[e.sym_buf + e.sym_next++] = r >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = t, r === 0 ? e.dyn_ltree[t * 2]++ : (e.matches++, r--, e.dyn_ltree[(Vt[t] + en + 1) * 2]++, e.dyn_dtree[Va(r) * 2]++), e.sym_next === e.sym_end);
var Mf = If, Nf = Ga, Zf = Lf, Of = Bf, Hf = Df, Uf = {
  _tr_init: Mf,
  _tr_stored_block: Nf,
  _tr_flush_block: Zf,
  _tr_tally: Of,
  _tr_align: Hf
};
const Ff = (e, r, t, i) => {
  let f = e & 65535 | 0, n = e >>> 16 & 65535 | 0, a = 0;
  for (; t !== 0; ) {
    a = t > 2e3 ? 2e3 : t, t -= a;
    do
      f = f + r[i++] | 0, n = n + f | 0;
    while (--a);
    f %= 65521, n %= 65521;
  }
  return f | n << 16 | 0;
};
var Xt = Ff;
const $f = () => {
  let e, r = [];
  for (var t = 0; t < 256; t++) {
    e = t;
    for (var i = 0; i < 8; i++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    r[t] = e;
  }
  return r;
}, Pf = new Uint32Array($f()), qf = (e, r, t, i) => {
  const f = Pf, n = i + t;
  e ^= -1;
  for (let a = i; a < n; a++)
    e = e >>> 8 ^ f[(e ^ r[a]) & 255];
  return e ^ -1;
};
var me = qf, bt = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, tn = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: Kf, _tr_stored_block: kr, _tr_flush_block: Yf, _tr_tally: st, _tr_align: Qf } = Uf, {
  Z_NO_FLUSH: ht,
  Z_PARTIAL_FLUSH: Vf,
  Z_FULL_FLUSH: jf,
  Z_FINISH: Fe,
  Z_BLOCK: $i,
  Z_OK: Se,
  Z_STREAM_END: Pi,
  Z_STREAM_ERROR: Xe,
  Z_DATA_ERROR: Xf,
  Z_BUF_ERROR: sr,
  Z_DEFAULT_COMPRESSION: Jf,
  Z_FILTERED: Wf,
  Z_HUFFMAN_ONLY: sn,
  Z_RLE: Gf,
  Z_FIXED: el,
  Z_DEFAULT_STRATEGY: tl,
  Z_UNKNOWN: nl,
  Z_DEFLATED: En
} = tn, rl = 9, il = 15, al = 8, ol = 29, fl = 256, mr = fl + 1 + ol, ll = 30, sl = 19, hl = 2 * mr + 1, ul = 15, oe = 3, lt = 258, Je = lt + oe + 1, cl = 32, Bt = 42, Or = 57, yr = 69, Ar = 73, Sr = 91, Rr = 103, vt = 113, Ft = 666, Ce = 1, Zt = 2, pt = 3, Ot = 4, dl = 3, wt = (e, r) => (e.msg = bt[r], r), qi = (e) => e * 2 - (e > 4 ? 9 : 0), ft = (e) => {
  let r = e.length;
  for (; --r >= 0; )
    e[r] = 0;
}, _l = (e) => {
  let r, t, i, f = e.w_size;
  r = e.hash_size, i = r;
  do
    t = e.head[--i], e.head[i] = t >= f ? t - f : 0;
  while (--r);
  r = f, i = r;
  do
    t = e.prev[--i], e.prev[i] = t >= f ? t - f : 0;
  while (--r);
};
let gl = (e, r, t) => (r << e.hash_shift ^ t) & e.hash_mask, ut = gl;
const Be = (e) => {
  const r = e.state;
  let t = r.pending;
  t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(r.pending_buf.subarray(r.pending_out, r.pending_out + t), e.next_out), e.next_out += t, r.pending_out += t, e.total_out += t, e.avail_out -= t, r.pending -= t, r.pending === 0 && (r.pending_out = 0));
}, Me = (e, r) => {
  Yf(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, r), e.block_start = e.strstart, Be(e.strm);
}, se = (e, r) => {
  e.pending_buf[e.pending++] = r;
}, Ut = (e, r) => {
  e.pending_buf[e.pending++] = r >>> 8 & 255, e.pending_buf[e.pending++] = r & 255;
}, Tr = (e, r, t, i) => {
  let f = e.avail_in;
  return f > i && (f = i), f === 0 ? 0 : (e.avail_in -= f, r.set(e.input.subarray(e.next_in, e.next_in + f), t), e.state.wrap === 1 ? e.adler = Xt(e.adler, r, f, t) : e.state.wrap === 2 && (e.adler = me(e.adler, r, f, t)), e.next_in += f, e.total_in += f, f);
}, eo = (e, r) => {
  let t = e.max_chain_length, i = e.strstart, f, n, a = e.prev_length, l = e.nice_match;
  const s = e.strstart > e.w_size - Je ? e.strstart - (e.w_size - Je) : 0, h = e.window, u = e.w_mask, d = e.prev, g = e.strstart + lt;
  let v = h[i + a - 1], c = h[i + a];
  e.prev_length >= e.good_match && (t >>= 2), l > e.lookahead && (l = e.lookahead);
  do
    if (f = r, !(h[f + a] !== c || h[f + a - 1] !== v || h[f] !== h[i] || h[++f] !== h[i + 1])) {
      i += 2, f++;
      do
        ;
      while (h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && i < g);
      if (n = lt - (g - i), i = g - lt, n > a) {
        if (e.match_start = r, a = n, n >= l)
          break;
        v = h[i + a - 1], c = h[i + a];
      }
    }
  while ((r = d[r & u]) > s && --t !== 0);
  return a <= e.lookahead ? a : e.lookahead;
}, Mt = (e) => {
  const r = e.w_size;
  let t, i, f;
  do {
    if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= r + (r - Je) && (e.window.set(e.window.subarray(r, r + r - i), 0), e.match_start -= r, e.strstart -= r, e.block_start -= r, e.insert > e.strstart && (e.insert = e.strstart), _l(e), i += r), e.strm.avail_in === 0)
      break;
    if (t = Tr(e.strm, e.window, e.strstart + e.lookahead, i), e.lookahead += t, e.lookahead + e.insert >= oe)
      for (f = e.strstart - e.insert, e.ins_h = e.window[f], e.ins_h = ut(e, e.ins_h, e.window[f + 1]); e.insert && (e.ins_h = ut(e, e.ins_h, e.window[f + oe - 1]), e.prev[f & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = f, f++, e.insert--, !(e.lookahead + e.insert < oe)); )
        ;
  } while (e.lookahead < Je && e.strm.avail_in !== 0);
}, to = (e, r) => {
  let t = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, i, f, n, a = 0, l = e.strm.avail_in;
  do {
    if (i = 65535, n = e.bi_valid + 42 >> 3, e.strm.avail_out < n || (n = e.strm.avail_out - n, f = e.strstart - e.block_start, i > f + e.strm.avail_in && (i = f + e.strm.avail_in), i > n && (i = n), i < t && (i === 0 && r !== Fe || r === ht || i !== f + e.strm.avail_in)))
      break;
    a = r === Fe && i === f + e.strm.avail_in ? 1 : 0, kr(e, 0, 0, a), e.pending_buf[e.pending - 4] = i, e.pending_buf[e.pending - 3] = i >> 8, e.pending_buf[e.pending - 2] = ~i, e.pending_buf[e.pending - 1] = ~i >> 8, Be(e.strm), f && (f > i && (f = i), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + f), e.strm.next_out), e.strm.next_out += f, e.strm.avail_out -= f, e.strm.total_out += f, e.block_start += f, i -= f), i && (Tr(e.strm, e.strm.output, e.strm.next_out, i), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i);
  } while (a === 0);
  return l -= e.strm.avail_in, l && (l >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= l && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - l, e.strm.next_in), e.strstart), e.strstart += l, e.insert += l > e.w_size - e.insert ? e.w_size - e.insert : l), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), a ? Ot : r !== ht && r !== Fe && e.strm.avail_in === 0 && e.strstart === e.block_start ? Zt : (n = e.window_size - e.strstart, e.strm.avail_in > n && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, n += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), n > e.strm.avail_in && (n = e.strm.avail_in), n && (Tr(e.strm, e.window, e.strstart, n), e.strstart += n, e.insert += n > e.w_size - e.insert ? e.w_size - e.insert : n), e.high_water < e.strstart && (e.high_water = e.strstart), n = e.bi_valid + 42 >> 3, n = e.pending_buf_size - n > 65535 ? 65535 : e.pending_buf_size - n, t = n > e.w_size ? e.w_size : n, f = e.strstart - e.block_start, (f >= t || (f || r === Fe) && r !== ht && e.strm.avail_in === 0 && f <= n) && (i = f > n ? n : f, a = r === Fe && e.strm.avail_in === 0 && i === f ? 1 : 0, kr(e, e.block_start, i, a), e.block_start += i, Be(e.strm)), a ? pt : Ce);
}, hr = (e, r) => {
  let t, i;
  for (; ; ) {
    if (e.lookahead < Je) {
      if (Mt(e), e.lookahead < Je && r === ht)
        return Ce;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= oe && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - Je && (e.match_length = eo(e, t)), e.match_length >= oe)
      if (i = st(e, e.strstart - e.match_start, e.match_length - oe), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= oe) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = ut(e, e.ins_h, e.window[e.strstart + 1]);
    else
      i = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (i && (Me(e, !1), e.strm.avail_out === 0))
      return Ce;
  }
  return e.insert = e.strstart < oe - 1 ? e.strstart : oe - 1, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;
}, It = (e, r) => {
  let t, i, f;
  for (; ; ) {
    if (e.lookahead < Je) {
      if (Mt(e), e.lookahead < Je && r === ht)
        return Ce;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= oe && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = oe - 1, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - Je && (e.match_length = eo(e, t), e.match_length <= 5 && (e.strategy === Wf || e.match_length === oe && e.strstart - e.match_start > 4096) && (e.match_length = oe - 1)), e.prev_length >= oe && e.match_length <= e.prev_length) {
      f = e.strstart + e.lookahead - oe, i = st(e, e.strstart - 1 - e.prev_match, e.prev_length - oe), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= f && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = oe - 1, e.strstart++, i && (Me(e, !1), e.strm.avail_out === 0))
        return Ce;
    } else if (e.match_available) {
      if (i = st(e, 0, e.window[e.strstart - 1]), i && Me(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Ce;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (i = st(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < oe - 1 ? e.strstart : oe - 1, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;
}, vl = (e, r) => {
  let t, i, f, n;
  const a = e.window;
  for (; ; ) {
    if (e.lookahead <= lt) {
      if (Mt(e), e.lookahead <= lt && r === ht)
        return Ce;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= oe && e.strstart > 0 && (f = e.strstart - 1, i = a[f], i === a[++f] && i === a[++f] && i === a[++f])) {
      n = e.strstart + lt;
      do
        ;
      while (i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && f < n);
      e.match_length = lt - (n - f), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= oe ? (t = st(e, 1, e.match_length - oe), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (t = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), t && (Me(e, !1), e.strm.avail_out === 0))
      return Ce;
  }
  return e.insert = 0, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;
}, wl = (e, r) => {
  let t;
  for (; ; ) {
    if (e.lookahead === 0 && (Mt(e), e.lookahead === 0)) {
      if (r === ht)
        return Ce;
      break;
    }
    if (e.match_length = 0, t = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, t && (Me(e, !1), e.strm.avail_out === 0))
      return Ce;
  }
  return e.insert = 0, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;
};
function Ve(e, r, t, i, f) {
  this.good_length = e, this.max_lazy = r, this.nice_length = t, this.max_chain = i, this.func = f;
}
const $t = [
  /*      good lazy nice chain */
  new Ve(0, 0, 0, 0, to),
  /* 0 store only */
  new Ve(4, 4, 8, 4, hr),
  /* 1 max speed, no lazy matches */
  new Ve(4, 5, 16, 8, hr),
  /* 2 */
  new Ve(4, 6, 32, 32, hr),
  /* 3 */
  new Ve(4, 4, 16, 16, It),
  /* 4 lazy matches */
  new Ve(8, 16, 32, 32, It),
  /* 5 */
  new Ve(8, 16, 128, 128, It),
  /* 6 */
  new Ve(8, 32, 128, 256, It),
  /* 7 */
  new Ve(32, 128, 258, 1024, It),
  /* 8 */
  new Ve(32, 258, 258, 4096, It)
  /* 9 max compression */
], bl = (e) => {
  e.window_size = 2 * e.w_size, ft(e.head), e.max_lazy_match = $t[e.level].max_lazy, e.good_match = $t[e.level].good_length, e.nice_match = $t[e.level].nice_length, e.max_chain_length = $t[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = oe - 1, e.match_available = 0, e.ins_h = 0;
};
function pl() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = En, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(hl * 2), this.dyn_dtree = new Uint16Array((2 * ll + 1) * 2), this.bl_tree = new Uint16Array((2 * sl + 1) * 2), ft(this.dyn_ltree), ft(this.dyn_dtree), ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(ul + 1), this.heap = new Uint16Array(2 * mr + 1), ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * mr + 1), ft(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const nn = (e) => {
  if (!e)
    return 1;
  const r = e.state;
  return !r || r.strm !== e || r.status !== Bt && //#ifdef GZIP
  r.status !== Or && //#endif
  r.status !== yr && r.status !== Ar && r.status !== Sr && r.status !== Rr && r.status !== vt && r.status !== Ft ? 1 : 0;
}, no = (e) => {
  if (nn(e))
    return wt(e, Xe);
  e.total_in = e.total_out = 0, e.data_type = nl;
  const r = e.state;
  return r.pending = 0, r.pending_out = 0, r.wrap < 0 && (r.wrap = -r.wrap), r.status = //#ifdef GZIP
  r.wrap === 2 ? Or : (
    //#endif
    r.wrap ? Bt : vt
  ), e.adler = r.wrap === 2 ? 0 : 1, r.last_flush = -2, Kf(r), Se;
}, ro = (e) => {
  const r = no(e);
  return r === Se && bl(e.state), r;
}, xl = (e, r) => nn(e) || e.state.wrap !== 2 ? Xe : (e.state.gzhead = r, Se), io = (e, r, t, i, f, n) => {
  if (!e)
    return Xe;
  let a = 1;
  if (r === Jf && (r = 6), i < 0 ? (a = 0, i = -i) : i > 15 && (a = 2, i -= 16), f < 1 || f > rl || t !== En || i < 8 || i > 15 || r < 0 || r > 9 || n < 0 || n > el || i === 8 && a !== 1)
    return wt(e, Xe);
  i === 8 && (i = 9);
  const l = new pl();
  return e.state = l, l.strm = e, l.status = Bt, l.wrap = a, l.gzhead = null, l.w_bits = i, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = f + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + oe - 1) / oe), l.window = new Uint8Array(l.w_size * 2), l.head = new Uint16Array(l.hash_size), l.prev = new Uint16Array(l.w_size), l.lit_bufsize = 1 << f + 6, l.pending_buf_size = l.lit_bufsize * 4, l.pending_buf = new Uint8Array(l.pending_buf_size), l.sym_buf = l.lit_bufsize, l.sym_end = (l.lit_bufsize - 1) * 3, l.level = r, l.strategy = n, l.method = t, ro(e);
}, El = (e, r) => io(e, r, En, il, al, tl), kl = (e, r) => {
  if (nn(e) || r > $i || r < 0)
    return e ? wt(e, Xe) : Xe;
  const t = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || t.status === Ft && r !== Fe)
    return wt(e, e.avail_out === 0 ? sr : Xe);
  const i = t.last_flush;
  if (t.last_flush = r, t.pending !== 0) {
    if (Be(e), e.avail_out === 0)
      return t.last_flush = -1, Se;
  } else if (e.avail_in === 0 && qi(r) <= qi(i) && r !== Fe)
    return wt(e, sr);
  if (t.status === Ft && e.avail_in !== 0)
    return wt(e, sr);
  if (t.status === Bt && t.wrap === 0 && (t.status = vt), t.status === Bt) {
    let f = En + (t.w_bits - 8 << 4) << 8, n = -1;
    if (t.strategy >= sn || t.level < 2 ? n = 0 : t.level < 6 ? n = 1 : t.level === 6 ? n = 2 : n = 3, f |= n << 6, t.strstart !== 0 && (f |= cl), f += 31 - f % 31, Ut(t, f), t.strstart !== 0 && (Ut(t, e.adler >>> 16), Ut(t, e.adler & 65535)), e.adler = 1, t.status = vt, Be(e), t.pending !== 0)
      return t.last_flush = -1, Se;
  }
  if (t.status === Or) {
    if (e.adler = 0, se(t, 31), se(t, 139), se(t, 8), t.gzhead)
      se(
        t,
        (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)
      ), se(t, t.gzhead.time & 255), se(t, t.gzhead.time >> 8 & 255), se(t, t.gzhead.time >> 16 & 255), se(t, t.gzhead.time >> 24 & 255), se(t, t.level === 9 ? 2 : t.strategy >= sn || t.level < 2 ? 4 : 0), se(t, t.gzhead.os & 255), t.gzhead.extra && t.gzhead.extra.length && (se(t, t.gzhead.extra.length & 255), se(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (e.adler = me(e.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = yr;
    else if (se(t, 0), se(t, 0), se(t, 0), se(t, 0), se(t, 0), se(t, t.level === 9 ? 2 : t.strategy >= sn || t.level < 2 ? 4 : 0), se(t, dl), t.status = vt, Be(e), t.pending !== 0)
      return t.last_flush = -1, Se;
  }
  if (t.status === yr) {
    if (t.gzhead.extra) {
      let f = t.pending, n = (t.gzhead.extra.length & 65535) - t.gzindex;
      for (; t.pending + n > t.pending_buf_size; ) {
        let l = t.pending_buf_size - t.pending;
        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + l), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex += l, Be(e), t.pending !== 0)
          return t.last_flush = -1, Se;
        f = 0, n -= l;
      }
      let a = new Uint8Array(t.gzhead.extra);
      t.pending_buf.set(a.subarray(t.gzindex, t.gzindex + n), t.pending), t.pending += n, t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex = 0;
    }
    t.status = Ar;
  }
  if (t.status === Ar) {
    if (t.gzhead.name) {
      let f = t.pending, n;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), Be(e), t.pending !== 0)
            return t.last_flush = -1, Se;
          f = 0;
        }
        t.gzindex < t.gzhead.name.length ? n = t.gzhead.name.charCodeAt(t.gzindex++) & 255 : n = 0, se(t, n);
      } while (n !== 0);
      t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex = 0;
    }
    t.status = Sr;
  }
  if (t.status === Sr) {
    if (t.gzhead.comment) {
      let f = t.pending, n;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), Be(e), t.pending !== 0)
            return t.last_flush = -1, Se;
          f = 0;
        }
        t.gzindex < t.gzhead.comment.length ? n = t.gzhead.comment.charCodeAt(t.gzindex++) & 255 : n = 0, se(t, n);
      } while (n !== 0);
      t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f));
    }
    t.status = Rr;
  }
  if (t.status === Rr) {
    if (t.gzhead.hcrc) {
      if (t.pending + 2 > t.pending_buf_size && (Be(e), t.pending !== 0))
        return t.last_flush = -1, Se;
      se(t, e.adler & 255), se(t, e.adler >> 8 & 255), e.adler = 0;
    }
    if (t.status = vt, Be(e), t.pending !== 0)
      return t.last_flush = -1, Se;
  }
  if (e.avail_in !== 0 || t.lookahead !== 0 || r !== ht && t.status !== Ft) {
    let f = t.level === 0 ? to(t, r) : t.strategy === sn ? wl(t, r) : t.strategy === Gf ? vl(t, r) : $t[t.level].func(t, r);
    if ((f === pt || f === Ot) && (t.status = Ft), f === Ce || f === pt)
      return e.avail_out === 0 && (t.last_flush = -1), Se;
    if (f === Zt && (r === Vf ? Qf(t) : r !== $i && (kr(t, 0, 0, !1), r === jf && (ft(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), Be(e), e.avail_out === 0))
      return t.last_flush = -1, Se;
  }
  return r !== Fe ? Se : t.wrap <= 0 ? Pi : (t.wrap === 2 ? (se(t, e.adler & 255), se(t, e.adler >> 8 & 255), se(t, e.adler >> 16 & 255), se(t, e.adler >> 24 & 255), se(t, e.total_in & 255), se(t, e.total_in >> 8 & 255), se(t, e.total_in >> 16 & 255), se(t, e.total_in >> 24 & 255)) : (Ut(t, e.adler >>> 16), Ut(t, e.adler & 65535)), Be(e), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? Se : Pi);
}, ml = (e) => {
  if (nn(e))
    return Xe;
  const r = e.state.status;
  return e.state = null, r === vt ? wt(e, Xf) : Se;
}, yl = (e, r) => {
  let t = r.length;
  if (nn(e))
    return Xe;
  const i = e.state, f = i.wrap;
  if (f === 2 || f === 1 && i.status !== Bt || i.lookahead)
    return Xe;
  if (f === 1 && (e.adler = Xt(e.adler, r, t, 0)), i.wrap = 0, t >= i.w_size) {
    f === 0 && (ft(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
    let s = new Uint8Array(i.w_size);
    s.set(r.subarray(t - i.w_size, t), 0), r = s, t = i.w_size;
  }
  const n = e.avail_in, a = e.next_in, l = e.input;
  for (e.avail_in = t, e.next_in = 0, e.input = r, Mt(i); i.lookahead >= oe; ) {
    let s = i.strstart, h = i.lookahead - (oe - 1);
    do
      i.ins_h = ut(i, i.ins_h, i.window[s + oe - 1]), i.prev[s & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = s, s++;
    while (--h);
    i.strstart = s, i.lookahead = oe - 1, Mt(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = oe - 1, i.match_available = 0, e.next_in = a, e.input = l, e.avail_in = n, i.wrap = f, Se;
};
var Al = El, Sl = io, Rl = ro, Tl = no, zl = xl, Cl = kl, Il = ml, Dl = yl, Ll = "pako deflate (from Nodeca project)", qt = {
  deflateInit: Al,
  deflateInit2: Sl,
  deflateReset: Rl,
  deflateResetKeep: Tl,
  deflateSetHeader: zl,
  deflate: Cl,
  deflateEnd: Il,
  deflateSetDictionary: Dl,
  deflateInfo: Ll
};
const Bl = (e, r) => Object.prototype.hasOwnProperty.call(e, r);
var Ml = function(e) {
  const r = Array.prototype.slice.call(arguments, 1);
  for (; r.length; ) {
    const t = r.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const i in t)
        Bl(t, i) && (e[i] = t[i]);
    }
  }
  return e;
}, Nl = (e) => {
  let r = 0;
  for (let i = 0, f = e.length; i < f; i++)
    r += e[i].length;
  const t = new Uint8Array(r);
  for (let i = 0, f = 0, n = e.length; i < n; i++) {
    let a = e[i];
    t.set(a, f), f += a.length;
  }
  return t;
}, kn = {
  assign: Ml,
  flattenChunks: Nl
};
let ao = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  ao = !1;
}
const Jt = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  Jt[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
Jt[254] = Jt[254] = 1;
var Zl = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let r, t, i, f, n, a = e.length, l = 0;
  for (f = 0; f < a; f++)
    t = e.charCodeAt(f), (t & 64512) === 55296 && f + 1 < a && (i = e.charCodeAt(f + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), f++)), l += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (r = new Uint8Array(l), n = 0, f = 0; n < l; f++)
    t = e.charCodeAt(f), (t & 64512) === 55296 && f + 1 < a && (i = e.charCodeAt(f + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), f++)), t < 128 ? r[n++] = t : t < 2048 ? (r[n++] = 192 | t >>> 6, r[n++] = 128 | t & 63) : t < 65536 ? (r[n++] = 224 | t >>> 12, r[n++] = 128 | t >>> 6 & 63, r[n++] = 128 | t & 63) : (r[n++] = 240 | t >>> 18, r[n++] = 128 | t >>> 12 & 63, r[n++] = 128 | t >>> 6 & 63, r[n++] = 128 | t & 63);
  return r;
};
const Ol = (e, r) => {
  if (r < 65534 && e.subarray && ao)
    return String.fromCharCode.apply(null, e.length === r ? e : e.subarray(0, r));
  let t = "";
  for (let i = 0; i < r; i++)
    t += String.fromCharCode(e[i]);
  return t;
};
var Hl = (e, r) => {
  const t = r || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, r));
  let i, f;
  const n = new Array(t * 2);
  for (f = 0, i = 0; i < t; ) {
    let a = e[i++];
    if (a < 128) {
      n[f++] = a;
      continue;
    }
    let l = Jt[a];
    if (l > 4) {
      n[f++] = 65533, i += l - 1;
      continue;
    }
    for (a &= l === 2 ? 31 : l === 3 ? 15 : 7; l > 1 && i < t; )
      a = a << 6 | e[i++] & 63, l--;
    if (l > 1) {
      n[f++] = 65533;
      continue;
    }
    a < 65536 ? n[f++] = a : (a -= 65536, n[f++] = 55296 | a >> 10 & 1023, n[f++] = 56320 | a & 1023);
  }
  return Ol(n, f);
}, Ul = (e, r) => {
  r = r || e.length, r > e.length && (r = e.length);
  let t = r - 1;
  for (; t >= 0 && (e[t] & 192) === 128; )
    t--;
  return t < 0 || t === 0 ? r : t + Jt[e[t]] > r ? t : r;
}, Wt = {
  string2buf: Zl,
  buf2string: Hl,
  utf8border: Ul
};
function Fl() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var oo = Fl;
const fo = Object.prototype.toString, {
  Z_NO_FLUSH: $l,
  Z_SYNC_FLUSH: Pl,
  Z_FULL_FLUSH: ql,
  Z_FINISH: Kl,
  Z_OK: pn,
  Z_STREAM_END: Yl,
  Z_DEFAULT_COMPRESSION: Ql,
  Z_DEFAULT_STRATEGY: Vl,
  Z_DEFLATED: jl
} = tn;
function rn(e) {
  this.options = kn.assign({
    level: Ql,
    method: jl,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Vl
  }, e || {});
  let r = this.options;
  r.raw && r.windowBits > 0 ? r.windowBits = -r.windowBits : r.gzip && r.windowBits > 0 && r.windowBits < 16 && (r.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new oo(), this.strm.avail_out = 0;
  let t = qt.deflateInit2(
    this.strm,
    r.level,
    r.method,
    r.windowBits,
    r.memLevel,
    r.strategy
  );
  if (t !== pn)
    throw new Error(bt[t]);
  if (r.header && qt.deflateSetHeader(this.strm, r.header), r.dictionary) {
    let i;
    if (typeof r.dictionary == "string" ? i = Wt.string2buf(r.dictionary) : fo.call(r.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(r.dictionary) : i = r.dictionary, t = qt.deflateSetDictionary(this.strm, i), t !== pn)
      throw new Error(bt[t]);
    this._dict_set = !0;
  }
}
rn.prototype.push = function(e, r) {
  const t = this.strm, i = this.options.chunkSize;
  let f, n;
  if (this.ended)
    return !1;
  for (r === ~~r ? n = r : n = r === !0 ? Kl : $l, typeof e == "string" ? t.input = Wt.string2buf(e) : fo.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    if (t.avail_out === 0 && (t.output = new Uint8Array(i), t.next_out = 0, t.avail_out = i), (n === Pl || n === ql) && t.avail_out <= 6) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (f = qt.deflate(t, n), f === Yl)
      return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), f = qt.deflateEnd(this.strm), this.onEnd(f), this.ended = !0, f === pn;
    if (t.avail_out === 0) {
      this.onData(t.output);
      continue;
    }
    if (n > 0 && t.next_out > 0) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (t.avail_in === 0) break;
  }
  return !0;
};
rn.prototype.onData = function(e) {
  this.chunks.push(e);
};
rn.prototype.onEnd = function(e) {
  e === pn && (this.result = kn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Hr(e, r) {
  const t = new rn(r);
  if (t.push(e, !0), t.err)
    throw t.msg || bt[t.err];
  return t.result;
}
function Xl(e, r) {
  return r = r || {}, r.raw = !0, Hr(e, r);
}
function Jl(e, r) {
  return r = r || {}, r.gzip = !0, Hr(e, r);
}
var Wl = rn, Gl = Hr, e0 = Xl, t0 = Jl, n0 = {
  Deflate: Wl,
  deflate: Gl,
  deflateRaw: e0,
  gzip: t0
};
const hn = 16209, r0 = 16191;
var i0 = function(r, t) {
  let i, f, n, a, l, s, h, u, d, g, v, c, R, S, b, x, m, k, L, z, E, T, I, D;
  const C = r.state;
  i = r.next_in, I = r.input, f = i + (r.avail_in - 5), n = r.next_out, D = r.output, a = n - (t - r.avail_out), l = n + (r.avail_out - 257), s = C.dmax, h = C.wsize, u = C.whave, d = C.wnext, g = C.window, v = C.hold, c = C.bits, R = C.lencode, S = C.distcode, b = (1 << C.lenbits) - 1, x = (1 << C.distbits) - 1;
  e:
    do {
      c < 15 && (v += I[i++] << c, c += 8, v += I[i++] << c, c += 8), m = R[v & b];
      t:
        for (; ; ) {
          if (k = m >>> 24, v >>>= k, c -= k, k = m >>> 16 & 255, k === 0)
            D[n++] = m & 65535;
          else if (k & 16) {
            L = m & 65535, k &= 15, k && (c < k && (v += I[i++] << c, c += 8), L += v & (1 << k) - 1, v >>>= k, c -= k), c < 15 && (v += I[i++] << c, c += 8, v += I[i++] << c, c += 8), m = S[v & x];
            n:
              for (; ; ) {
                if (k = m >>> 24, v >>>= k, c -= k, k = m >>> 16 & 255, k & 16) {
                  if (z = m & 65535, k &= 15, c < k && (v += I[i++] << c, c += 8, c < k && (v += I[i++] << c, c += 8)), z += v & (1 << k) - 1, z > s) {
                    r.msg = "invalid distance too far back", C.mode = hn;
                    break e;
                  }
                  if (v >>>= k, c -= k, k = n - a, z > k) {
                    if (k = z - k, k > u && C.sane) {
                      r.msg = "invalid distance too far back", C.mode = hn;
                      break e;
                    }
                    if (E = 0, T = g, d === 0) {
                      if (E += h - k, k < L) {
                        L -= k;
                        do
                          D[n++] = g[E++];
                        while (--k);
                        E = n - z, T = D;
                      }
                    } else if (d < k) {
                      if (E += h + d - k, k -= d, k < L) {
                        L -= k;
                        do
                          D[n++] = g[E++];
                        while (--k);
                        if (E = 0, d < L) {
                          k = d, L -= k;
                          do
                            D[n++] = g[E++];
                          while (--k);
                          E = n - z, T = D;
                        }
                      }
                    } else if (E += d - k, k < L) {
                      L -= k;
                      do
                        D[n++] = g[E++];
                      while (--k);
                      E = n - z, T = D;
                    }
                    for (; L > 2; )
                      D[n++] = T[E++], D[n++] = T[E++], D[n++] = T[E++], L -= 3;
                    L && (D[n++] = T[E++], L > 1 && (D[n++] = T[E++]));
                  } else {
                    E = n - z;
                    do
                      D[n++] = D[E++], D[n++] = D[E++], D[n++] = D[E++], L -= 3;
                    while (L > 2);
                    L && (D[n++] = D[E++], L > 1 && (D[n++] = D[E++]));
                  }
                } else if ((k & 64) === 0) {
                  m = S[(m & 65535) + (v & (1 << k) - 1)];
                  continue n;
                } else {
                  r.msg = "invalid distance code", C.mode = hn;
                  break e;
                }
                break;
              }
          } else if ((k & 64) === 0) {
            m = R[(m & 65535) + (v & (1 << k) - 1)];
            continue t;
          } else if (k & 32) {
            C.mode = r0;
            break e;
          } else {
            r.msg = "invalid literal/length code", C.mode = hn;
            break e;
          }
          break;
        }
    } while (i < f && n < l);
  L = c >> 3, i -= L, c -= L << 3, v &= (1 << c) - 1, r.next_in = i, r.next_out = n, r.avail_in = i < f ? 5 + (f - i) : 5 - (i - f), r.avail_out = n < l ? 257 + (l - n) : 257 - (n - l), C.hold = v, C.bits = c;
};
const Dt = 15, Ki = 852, Yi = 592, Qi = 0, ur = 1, Vi = 2, a0 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), o0 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), f0 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), l0 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), s0 = (e, r, t, i, f, n, a, l) => {
  const s = l.bits;
  let h = 0, u = 0, d = 0, g = 0, v = 0, c = 0, R = 0, S = 0, b = 0, x = 0, m, k, L, z, E, T = null, I;
  const D = new Uint16Array(Dt + 1), C = new Uint16Array(Dt + 1);
  let O = null, N, U, X;
  for (h = 0; h <= Dt; h++)
    D[h] = 0;
  for (u = 0; u < i; u++)
    D[r[t + u]]++;
  for (v = s, g = Dt; g >= 1 && D[g] === 0; g--)
    ;
  if (v > g && (v = g), g === 0)
    return f[n++] = 1 << 24 | 64 << 16 | 0, f[n++] = 1 << 24 | 64 << 16 | 0, l.bits = 1, 0;
  for (d = 1; d < g && D[d] === 0; d++)
    ;
  for (v < d && (v = d), S = 1, h = 1; h <= Dt; h++)
    if (S <<= 1, S -= D[h], S < 0)
      return -1;
  if (S > 0 && (e === Qi || g !== 1))
    return -1;
  for (C[1] = 0, h = 1; h < Dt; h++)
    C[h + 1] = C[h] + D[h];
  for (u = 0; u < i; u++)
    r[t + u] !== 0 && (a[C[r[t + u]]++] = u);
  if (e === Qi ? (T = O = a, I = 20) : e === ur ? (T = a0, O = o0, I = 257) : (T = f0, O = l0, I = 0), x = 0, u = 0, h = d, E = n, c = v, R = 0, L = -1, b = 1 << v, z = b - 1, e === ur && b > Ki || e === Vi && b > Yi)
    return 1;
  for (; ; ) {
    N = h - R, a[u] + 1 < I ? (U = 0, X = a[u]) : a[u] >= I ? (U = O[a[u] - I], X = T[a[u] - I]) : (U = 96, X = 0), m = 1 << h - R, k = 1 << c, d = k;
    do
      k -= m, f[E + (x >> R) + k] = N << 24 | U << 16 | X | 0;
    while (k !== 0);
    for (m = 1 << h - 1; x & m; )
      m >>= 1;
    if (m !== 0 ? (x &= m - 1, x += m) : x = 0, u++, --D[h] === 0) {
      if (h === g)
        break;
      h = r[t + a[u]];
    }
    if (h > v && (x & z) !== L) {
      for (R === 0 && (R = v), E += d, c = h - R, S = 1 << c; c + R < g && (S -= D[c + R], !(S <= 0)); )
        c++, S <<= 1;
      if (b += 1 << c, e === ur && b > Ki || e === Vi && b > Yi)
        return 1;
      L = x & z, f[L] = v << 24 | c << 16 | E - n | 0;
    }
  }
  return x !== 0 && (f[E + x] = h - R << 24 | 64 << 16 | 0), l.bits = v, 0;
};
var Kt = s0;
const h0 = 0, lo = 1, so = 2, {
  Z_FINISH: ji,
  Z_BLOCK: u0,
  Z_TREES: un,
  Z_OK: xt,
  Z_STREAM_END: c0,
  Z_NEED_DICT: d0,
  Z_STREAM_ERROR: $e,
  Z_DATA_ERROR: ho,
  Z_MEM_ERROR: uo,
  Z_BUF_ERROR: _0,
  Z_DEFLATED: Xi
} = tn, mn = 16180, Ji = 16181, Wi = 16182, Gi = 16183, ea = 16184, ta = 16185, na = 16186, ra = 16187, ia = 16188, aa = 16189, xn = 16190, et = 16191, cr = 16192, oa = 16193, dr = 16194, fa = 16195, la = 16196, sa = 16197, ha = 16198, cn = 16199, dn = 16200, ua = 16201, ca = 16202, da = 16203, _a = 16204, ga = 16205, _r = 16206, va = 16207, wa = 16208, _e = 16209, co = 16210, _o = 16211, g0 = 852, v0 = 592, w0 = 15, b0 = w0, ba = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function p0() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const mt = (e) => {
  if (!e)
    return 1;
  const r = e.state;
  return !r || r.strm !== e || r.mode < mn || r.mode > _o ? 1 : 0;
}, go = (e) => {
  if (mt(e))
    return $e;
  const r = e.state;
  return e.total_in = e.total_out = r.total = 0, e.msg = "", r.wrap && (e.adler = r.wrap & 1), r.mode = mn, r.last = 0, r.havedict = 0, r.flags = -1, r.dmax = 32768, r.head = null, r.hold = 0, r.bits = 0, r.lencode = r.lendyn = new Int32Array(g0), r.distcode = r.distdyn = new Int32Array(v0), r.sane = 1, r.back = -1, xt;
}, vo = (e) => {
  if (mt(e))
    return $e;
  const r = e.state;
  return r.wsize = 0, r.whave = 0, r.wnext = 0, go(e);
}, wo = (e, r) => {
  let t;
  if (mt(e))
    return $e;
  const i = e.state;
  return r < 0 ? (t = 0, r = -r) : (t = (r >> 4) + 5, r < 48 && (r &= 15)), r && (r < 8 || r > 15) ? $e : (i.window !== null && i.wbits !== r && (i.window = null), i.wrap = t, i.wbits = r, vo(e));
}, bo = (e, r) => {
  if (!e)
    return $e;
  const t = new p0();
  e.state = t, t.strm = e, t.window = null, t.mode = mn;
  const i = wo(e, r);
  return i !== xt && (e.state = null), i;
}, x0 = (e) => bo(e, b0);
let pa = !0, gr, vr;
const E0 = (e) => {
  if (pa) {
    gr = new Int32Array(512), vr = new Int32Array(32);
    let r = 0;
    for (; r < 144; )
      e.lens[r++] = 8;
    for (; r < 256; )
      e.lens[r++] = 9;
    for (; r < 280; )
      e.lens[r++] = 7;
    for (; r < 288; )
      e.lens[r++] = 8;
    for (Kt(lo, e.lens, 0, 288, gr, 0, e.work, { bits: 9 }), r = 0; r < 32; )
      e.lens[r++] = 5;
    Kt(so, e.lens, 0, 32, vr, 0, e.work, { bits: 5 }), pa = !1;
  }
  e.lencode = gr, e.lenbits = 9, e.distcode = vr, e.distbits = 5;
}, po = (e, r, t, i) => {
  let f;
  const n = e.state;
  return n.window === null && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new Uint8Array(n.wsize)), i >= n.wsize ? (n.window.set(r.subarray(t - n.wsize, t), 0), n.wnext = 0, n.whave = n.wsize) : (f = n.wsize - n.wnext, f > i && (f = i), n.window.set(r.subarray(t - i, t - i + f), n.wnext), i -= f, i ? (n.window.set(r.subarray(t - i, t), 0), n.wnext = i, n.whave = n.wsize) : (n.wnext += f, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += f))), 0;
}, k0 = (e, r) => {
  let t, i, f, n, a, l, s, h, u, d, g, v, c, R, S = 0, b, x, m, k, L, z, E, T;
  const I = new Uint8Array(4);
  let D, C;
  const O = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (mt(e) || !e.output || !e.input && e.avail_in !== 0)
    return $e;
  t = e.state, t.mode === et && (t.mode = cr), a = e.next_out, f = e.output, s = e.avail_out, n = e.next_in, i = e.input, l = e.avail_in, h = t.hold, u = t.bits, d = l, g = s, T = xt;
  e:
    for (; ; )
      switch (t.mode) {
        case mn:
          if (t.wrap === 0) {
            t.mode = cr;
            break;
          }
          for (; u < 16; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if (t.wrap & 2 && h === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0), h = 0, u = 0, t.mode = Ji;
            break;
          }
          if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
          (((h & 255) << 8) + (h >> 8)) % 31) {
            e.msg = "incorrect header check", t.mode = _e;
            break;
          }
          if ((h & 15) !== Xi) {
            e.msg = "unknown compression method", t.mode = _e;
            break;
          }
          if (h >>>= 4, u -= 4, E = (h & 15) + 8, t.wbits === 0 && (t.wbits = E), E > 15 || E > t.wbits) {
            e.msg = "invalid window size", t.mode = _e;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = h & 512 ? aa : et, h = 0, u = 0;
          break;
        case Ji:
          for (; u < 16; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if (t.flags = h, (t.flags & 255) !== Xi) {
            e.msg = "unknown compression method", t.mode = _e;
            break;
          }
          if (t.flags & 57344) {
            e.msg = "unknown header flags set", t.mode = _e;
            break;
          }
          t.head && (t.head.text = h >> 8 & 1), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0, t.mode = Wi;
        /* falls through */
        case Wi:
          for (; u < 32; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          t.head && (t.head.time = h), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, I[2] = h >>> 16 & 255, I[3] = h >>> 24 & 255, t.check = me(t.check, I, 4, 0)), h = 0, u = 0, t.mode = Gi;
        /* falls through */
        case Gi:
          for (; u < 16; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          t.head && (t.head.xflags = h & 255, t.head.os = h >> 8), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0, t.mode = ea;
        /* falls through */
        case ea:
          if (t.flags & 1024) {
            for (; u < 16; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            t.length = h, t.head && (t.head.extra_len = h), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0;
          } else t.head && (t.head.extra = null);
          t.mode = ta;
        /* falls through */
        case ta:
          if (t.flags & 1024 && (v = t.length, v > l && (v = l), v && (t.head && (E = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(
            i.subarray(
              n,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              n + v
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            E
          )), t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, t.length -= v), t.length))
            break e;
          t.length = 0, t.mode = na;
        /* falls through */
        case na:
          if (t.flags & 2048) {
            if (l === 0)
              break e;
            v = 0;
            do
              E = i[n + v++], t.head && E && t.length < 65536 && (t.head.name += String.fromCharCode(E));
            while (E && v < l);
            if (t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, E)
              break e;
          } else t.head && (t.head.name = null);
          t.length = 0, t.mode = ra;
        /* falls through */
        case ra:
          if (t.flags & 4096) {
            if (l === 0)
              break e;
            v = 0;
            do
              E = i[n + v++], t.head && E && t.length < 65536 && (t.head.comment += String.fromCharCode(E));
            while (E && v < l);
            if (t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, E)
              break e;
          } else t.head && (t.head.comment = null);
          t.mode = ia;
        /* falls through */
        case ia:
          if (t.flags & 512) {
            for (; u < 16; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            if (t.wrap & 4 && h !== (t.check & 65535)) {
              e.msg = "header crc mismatch", t.mode = _e;
              break;
            }
            h = 0, u = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = et;
          break;
        case aa:
          for (; u < 32; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          e.adler = t.check = ba(h), h = 0, u = 0, t.mode = xn;
        /* falls through */
        case xn:
          if (t.havedict === 0)
            return e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, d0;
          e.adler = t.check = 1, t.mode = et;
        /* falls through */
        case et:
          if (r === u0 || r === un)
            break e;
        /* falls through */
        case cr:
          if (t.last) {
            h >>>= u & 7, u -= u & 7, t.mode = _r;
            break;
          }
          for (; u < 3; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          switch (t.last = h & 1, h >>>= 1, u -= 1, h & 3) {
            case 0:
              t.mode = oa;
              break;
            case 1:
              if (E0(t), t.mode = cn, r === un) {
                h >>>= 2, u -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = la;
              break;
            case 3:
              e.msg = "invalid block type", t.mode = _e;
          }
          h >>>= 2, u -= 2;
          break;
        case oa:
          for (h >>>= u & 7, u -= u & 7; u < 32; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if ((h & 65535) !== (h >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", t.mode = _e;
            break;
          }
          if (t.length = h & 65535, h = 0, u = 0, t.mode = dr, r === un)
            break e;
        /* falls through */
        case dr:
          t.mode = fa;
        /* falls through */
        case fa:
          if (v = t.length, v) {
            if (v > l && (v = l), v > s && (v = s), v === 0)
              break e;
            f.set(i.subarray(n, n + v), a), l -= v, n += v, s -= v, a += v, t.length -= v;
            break;
          }
          t.mode = et;
          break;
        case la:
          for (; u < 14; ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if (t.nlen = (h & 31) + 257, h >>>= 5, u -= 5, t.ndist = (h & 31) + 1, h >>>= 5, u -= 5, t.ncode = (h & 15) + 4, h >>>= 4, u -= 4, t.nlen > 286 || t.ndist > 30) {
            e.msg = "too many length or distance symbols", t.mode = _e;
            break;
          }
          t.have = 0, t.mode = sa;
        /* falls through */
        case sa:
          for (; t.have < t.ncode; ) {
            for (; u < 3; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            t.lens[O[t.have++]] = h & 7, h >>>= 3, u -= 3;
          }
          for (; t.have < 19; )
            t.lens[O[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, D = { bits: t.lenbits }, T = Kt(h0, t.lens, 0, 19, t.lencode, 0, t.work, D), t.lenbits = D.bits, T) {
            e.msg = "invalid code lengths set", t.mode = _e;
            break;
          }
          t.have = 0, t.mode = ha;
        /* falls through */
        case ha:
          for (; t.have < t.nlen + t.ndist; ) {
            for (; S = t.lencode[h & (1 << t.lenbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            if (m < 16)
              h >>>= b, u -= b, t.lens[t.have++] = m;
            else {
              if (m === 16) {
                for (C = b + 2; u < C; ) {
                  if (l === 0)
                    break e;
                  l--, h += i[n++] << u, u += 8;
                }
                if (h >>>= b, u -= b, t.have === 0) {
                  e.msg = "invalid bit length repeat", t.mode = _e;
                  break;
                }
                E = t.lens[t.have - 1], v = 3 + (h & 3), h >>>= 2, u -= 2;
              } else if (m === 17) {
                for (C = b + 3; u < C; ) {
                  if (l === 0)
                    break e;
                  l--, h += i[n++] << u, u += 8;
                }
                h >>>= b, u -= b, E = 0, v = 3 + (h & 7), h >>>= 3, u -= 3;
              } else {
                for (C = b + 7; u < C; ) {
                  if (l === 0)
                    break e;
                  l--, h += i[n++] << u, u += 8;
                }
                h >>>= b, u -= b, E = 0, v = 11 + (h & 127), h >>>= 7, u -= 7;
              }
              if (t.have + v > t.nlen + t.ndist) {
                e.msg = "invalid bit length repeat", t.mode = _e;
                break;
              }
              for (; v--; )
                t.lens[t.have++] = E;
            }
          }
          if (t.mode === _e)
            break;
          if (t.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", t.mode = _e;
            break;
          }
          if (t.lenbits = 9, D = { bits: t.lenbits }, T = Kt(lo, t.lens, 0, t.nlen, t.lencode, 0, t.work, D), t.lenbits = D.bits, T) {
            e.msg = "invalid literal/lengths set", t.mode = _e;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, D = { bits: t.distbits }, T = Kt(so, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, D), t.distbits = D.bits, T) {
            e.msg = "invalid distances set", t.mode = _e;
            break;
          }
          if (t.mode = cn, r === un)
            break e;
        /* falls through */
        case cn:
          t.mode = dn;
        /* falls through */
        case dn:
          if (l >= 6 && s >= 258) {
            e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, i0(e, g), a = e.next_out, f = e.output, s = e.avail_out, n = e.next_in, i = e.input, l = e.avail_in, h = t.hold, u = t.bits, t.mode === et && (t.back = -1);
            break;
          }
          for (t.back = 0; S = t.lencode[h & (1 << t.lenbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if (x && (x & 240) === 0) {
            for (k = b, L = x, z = m; S = t.lencode[z + ((h & (1 << k + L) - 1) >> k)], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(k + b <= u); ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            h >>>= k, u -= k, t.back += k;
          }
          if (h >>>= b, u -= b, t.back += b, t.length = m, x === 0) {
            t.mode = ga;
            break;
          }
          if (x & 32) {
            t.back = -1, t.mode = et;
            break;
          }
          if (x & 64) {
            e.msg = "invalid literal/length code", t.mode = _e;
            break;
          }
          t.extra = x & 15, t.mode = ua;
        /* falls through */
        case ua:
          if (t.extra) {
            for (C = t.extra; u < C; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            t.length += h & (1 << t.extra) - 1, h >>>= t.extra, u -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = ca;
        /* falls through */
        case ca:
          for (; S = t.distcode[h & (1 << t.distbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {
            if (l === 0)
              break e;
            l--, h += i[n++] << u, u += 8;
          }
          if ((x & 240) === 0) {
            for (k = b, L = x, z = m; S = t.distcode[z + ((h & (1 << k + L) - 1) >> k)], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(k + b <= u); ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            h >>>= k, u -= k, t.back += k;
          }
          if (h >>>= b, u -= b, t.back += b, x & 64) {
            e.msg = "invalid distance code", t.mode = _e;
            break;
          }
          t.offset = m, t.extra = x & 15, t.mode = da;
        /* falls through */
        case da:
          if (t.extra) {
            for (C = t.extra; u < C; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            t.offset += h & (1 << t.extra) - 1, h >>>= t.extra, u -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            e.msg = "invalid distance too far back", t.mode = _e;
            break;
          }
          t.mode = _a;
        /* falls through */
        case _a:
          if (s === 0)
            break e;
          if (v = g - s, t.offset > v) {
            if (v = t.offset - v, v > t.whave && t.sane) {
              e.msg = "invalid distance too far back", t.mode = _e;
              break;
            }
            v > t.wnext ? (v -= t.wnext, c = t.wsize - v) : c = t.wnext - v, v > t.length && (v = t.length), R = t.window;
          } else
            R = f, c = a - t.offset, v = t.length;
          v > s && (v = s), s -= v, t.length -= v;
          do
            f[a++] = R[c++];
          while (--v);
          t.length === 0 && (t.mode = dn);
          break;
        case ga:
          if (s === 0)
            break e;
          f[a++] = t.length, s--, t.mode = dn;
          break;
        case _r:
          if (t.wrap) {
            for (; u < 32; ) {
              if (l === 0)
                break e;
              l--, h |= i[n++] << u, u += 8;
            }
            if (g -= s, e.total_out += g, t.total += g, t.wrap & 4 && g && (e.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            t.flags ? me(t.check, f, g, a - g) : Xt(t.check, f, g, a - g)), g = s, t.wrap & 4 && (t.flags ? h : ba(h)) !== t.check) {
              e.msg = "incorrect data check", t.mode = _e;
              break;
            }
            h = 0, u = 0;
          }
          t.mode = va;
        /* falls through */
        case va:
          if (t.wrap && t.flags) {
            for (; u < 32; ) {
              if (l === 0)
                break e;
              l--, h += i[n++] << u, u += 8;
            }
            if (t.wrap & 4 && h !== (t.total & 4294967295)) {
              e.msg = "incorrect length check", t.mode = _e;
              break;
            }
            h = 0, u = 0;
          }
          t.mode = wa;
        /* falls through */
        case wa:
          T = c0;
          break e;
        case _e:
          T = ho;
          break e;
        case co:
          return uo;
        case _o:
        /* falls through */
        default:
          return $e;
      }
  return e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, (t.wsize || g !== e.avail_out && t.mode < _e && (t.mode < _r || r !== ji)) && po(e, e.output, e.next_out, g - e.avail_out), d -= e.avail_in, g -= e.avail_out, e.total_in += d, e.total_out += g, t.total += g, t.wrap & 4 && g && (e.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  t.flags ? me(t.check, f, g, e.next_out - g) : Xt(t.check, f, g, e.next_out - g)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === et ? 128 : 0) + (t.mode === cn || t.mode === dr ? 256 : 0), (d === 0 && g === 0 || r === ji) && T === xt && (T = _0), T;
}, m0 = (e) => {
  if (mt(e))
    return $e;
  let r = e.state;
  return r.window && (r.window = null), e.state = null, xt;
}, y0 = (e, r) => {
  if (mt(e))
    return $e;
  const t = e.state;
  return (t.wrap & 2) === 0 ? $e : (t.head = r, r.done = !1, xt);
}, A0 = (e, r) => {
  const t = r.length;
  let i, f, n;
  return mt(e) || (i = e.state, i.wrap !== 0 && i.mode !== xn) ? $e : i.mode === xn && (f = 1, f = Xt(f, r, t, 0), f !== i.check) ? ho : (n = po(e, r, t, t), n ? (i.mode = co, uo) : (i.havedict = 1, xt));
};
var S0 = vo, R0 = wo, T0 = go, z0 = x0, C0 = bo, I0 = k0, D0 = m0, L0 = y0, B0 = A0, M0 = "pako inflate (from Nodeca project)", nt = {
  inflateReset: S0,
  inflateReset2: R0,
  inflateResetKeep: T0,
  inflateInit: z0,
  inflateInit2: C0,
  inflate: I0,
  inflateEnd: D0,
  inflateGetHeader: L0,
  inflateSetDictionary: B0,
  inflateInfo: M0
};
function N0() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Z0 = N0;
const xo = Object.prototype.toString, {
  Z_NO_FLUSH: O0,
  Z_FINISH: H0,
  Z_OK: Gt,
  Z_STREAM_END: wr,
  Z_NEED_DICT: br,
  Z_STREAM_ERROR: U0,
  Z_DATA_ERROR: xa,
  Z_MEM_ERROR: F0
} = tn;
function an(e) {
  this.options = kn.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const r = this.options;
  r.raw && r.windowBits >= 0 && r.windowBits < 16 && (r.windowBits = -r.windowBits, r.windowBits === 0 && (r.windowBits = -15)), r.windowBits >= 0 && r.windowBits < 16 && !(e && e.windowBits) && (r.windowBits += 32), r.windowBits > 15 && r.windowBits < 48 && (r.windowBits & 15) === 0 && (r.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new oo(), this.strm.avail_out = 0;
  let t = nt.inflateInit2(
    this.strm,
    r.windowBits
  );
  if (t !== Gt)
    throw new Error(bt[t]);
  if (this.header = new Z0(), nt.inflateGetHeader(this.strm, this.header), r.dictionary && (typeof r.dictionary == "string" ? r.dictionary = Wt.string2buf(r.dictionary) : xo.call(r.dictionary) === "[object ArrayBuffer]" && (r.dictionary = new Uint8Array(r.dictionary)), r.raw && (t = nt.inflateSetDictionary(this.strm, r.dictionary), t !== Gt)))
    throw new Error(bt[t]);
}
an.prototype.push = function(e, r) {
  const t = this.strm, i = this.options.chunkSize, f = this.options.dictionary;
  let n, a, l;
  if (this.ended) return !1;
  for (r === ~~r ? a = r : a = r === !0 ? H0 : O0, xo.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(i), t.next_out = 0, t.avail_out = i), n = nt.inflate(t, a), n === br && f && (n = nt.inflateSetDictionary(t, f), n === Gt ? n = nt.inflate(t, a) : n === xa && (n = br)); t.avail_in > 0 && n === wr && t.state.wrap > 0 && e[t.next_in] !== 0; )
      nt.inflateReset(t), n = nt.inflate(t, a);
    switch (n) {
      case U0:
      case xa:
      case br:
      case F0:
        return this.onEnd(n), this.ended = !0, !1;
    }
    if (l = t.avail_out, t.next_out && (t.avail_out === 0 || n === wr))
      if (this.options.to === "string") {
        let s = Wt.utf8border(t.output, t.next_out), h = t.next_out - s, u = Wt.buf2string(t.output, s);
        t.next_out = h, t.avail_out = i - h, h && t.output.set(t.output.subarray(s, s + h), 0), this.onData(u);
      } else
        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (!(n === Gt && l === 0)) {
      if (n === wr)
        return n = nt.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, !0;
      if (t.avail_in === 0) break;
    }
  }
  return !0;
};
an.prototype.onData = function(e) {
  this.chunks.push(e);
};
an.prototype.onEnd = function(e) {
  e === Gt && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = kn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Ur(e, r) {
  const t = new an(r);
  if (t.push(e), t.err) throw t.msg || bt[t.err];
  return t.result;
}
function $0(e, r) {
  return r = r || {}, r.raw = !0, Ur(e, r);
}
var P0 = an, q0 = Ur, K0 = $0, Y0 = Ur, Q0 = {
  Inflate: P0,
  inflate: q0,
  inflateRaw: K0,
  ungzip: Y0
};
const { Deflate: V0, deflate: j0, deflateRaw: X0, gzip: J0 } = n0, { Inflate: W0, inflate: G0, inflateRaw: e1, ungzip: t1 } = Q0;
var n1 = V0, r1 = j0, i1 = X0, a1 = J0, o1 = W0, f1 = G0, l1 = e1, s1 = t1, h1 = tn, Eo = {
  Deflate: n1,
  deflate: r1,
  deflateRaw: i1,
  gzip: a1,
  Inflate: o1,
  inflate: f1,
  inflateRaw: l1,
  ungzip: s1,
  constants: h1
};
function zr(e) {
  const r = e.match(/.{1,2}/g) ?? [];
  return Uint8Array.from(r.map((t) => parseInt(t, 16)));
}
function u1(e) {
  const r = atob(e), t = r.length, i = new Uint8Array(t);
  for (let f = 0; f < t; f++)
    i[f] = r.charCodeAt(f);
  return i;
}
function Ea(e) {
  if (e < 0 || e > 1295 || !Number.isInteger(e))
    throw new Error("Out of range");
  return e.toString(36).toUpperCase().padStart(2, "0");
}
async function c1(e) {
  const r = new FileReader();
  return new Promise((t, i) => {
    r.onload = (f) => {
      var a;
      const n = (a = f.target) == null ? void 0 : a.result;
      n instanceof ArrayBuffer ? t(new Uint8Array(n)) : i(new Error("FileReader result is not an ArrayBuffer"));
    }, r.readAsArrayBuffer(e);
  });
}
function ka(e) {
  const r = e.reduce((f, n) => f + n.length, 0), t = new Uint8Array(r);
  let i = 0;
  for (const f of e)
    t.set(f, i), i += f.length;
  return t;
}
function Cr(e) {
  return e in Ma;
}
function ma(e) {
  return e >= 1 && e <= 1295;
}
function d1(e) {
  const r = {
    minVersion: e.minVersion ?? 5,
    maxVersion: e.maxVersion ?? 40,
    minSplit: e.minSplit ?? 1,
    maxSplit: e.maxSplit ?? 1295,
    encoding: e.encoding ?? "Z"
  };
  if (r.minVersion > r.maxVersion || !Cr(r.minVersion) || !Cr(r.maxVersion))
    throw new Error("min/max version out of range");
  if (!ma(r.minSplit) || !ma(r.maxSplit) || r.minSplit > r.maxSplit)
    throw new Error("min/max split out of range");
  return r;
}
function ya(e) {
  try {
    return new Uint8Array([112, 115, 98, 116, 255]).every((r, t) => r === e[t]);
  } catch {
    return !1;
  }
}
function _1(e) {
  e = [...e];
  for (let r = e.length - 1; r > 0; r--) {
    const t = Math.floor(Math.random() * (r + 1)), i = e[r];
    e[r] = e[t], e[t] = i;
  }
  return e;
}
function g1(e) {
  if (!Cr(e))
    throw new Error("Invalid version");
  return Ma[e]["L"][2];
}
function v1(e, r) {
  if (r = r ?? "Z", r === "H")
    return {
      encoding: r,
      encoded: e.reduce((t, i) => t + i.toString(16).padStart(2, "0"), "").toUpperCase()
    };
  if (r === "Z") {
    const t = Eo.deflate(e, { windowBits: -10 });
    t.length >= e.length ? r = "2" : (r = "Z", e = t);
  }
  return {
    encoding: r,
    // base32 without padding
    encoded: Oa.encode(e).replace(/=*$/, "")
  };
}
function w1(e, r) {
  if (r === "H")
    return ka(e.map((i) => zr(i)));
  const t = ka(
    e.map((i) => {
      const f = (8 - i.length % 8) % 8;
      return Oa.decode(i + "=".repeat(f));
    })
  );
  return r === "Z" ? Eo.inflate(t, { windowBits: -10 }) : t;
}
async function x1(e, r, t = {}) {
  if (typeof window > "u")
    throw new Error("renderQRImage is only available in a web browser environment.");
  const i = t.mode ?? "animated";
  let f = 4;
  if (typeof t.margin == "number" && t.margin >= 0)
    f = t.margin;
  else if (typeof t.margin == "string" && /^\d+(\.\d+)?%$/.test(t.margin)) {
    const h = Number(t.margin.slice(0, -1));
    f = lf[r] * h / 100;
  } else if (t.margin !== void 0)
    throw new Error(
      'Invalid margin value. Expected a non-negative number or percentage string like "10%". Got: ' + t.margin
    );
  f = Math.round(f);
  const n = t.scale ?? 4;
  if (n < 1)
    throw new Error("scale cannot be less than 1");
  let a = 0, l = 0;
  const s = [];
  for (let h = 0; h < e.length; h++) {
    const u = e[h], d = await qo.toDataURL([{ data: u, mode: "alphanumeric" }], {
      errorCorrectionLevel: "L",
      version: r,
      margin: f,
      scale: n
    }), g = new Image();
    if (g.src = d, await g.decode(), h === 0)
      a = g.width, l = g.height;
    else if (g.width !== a)
      throw new Error("QR codes must all be the same size");
    s.push(g);
  }
  if (i === "stacked") {
    const h = a / 1.5, u = l * e.length + h * (e.length - 1), d = document.createElement("canvas"), g = d.getContext("2d");
    if (!g)
      throw new Error("Could not get 2d context for canvas element.");
    d.width = a, d.height = u, g.fillStyle = "#fff", g.fillRect(0, 0, a, u);
    for (let c = 0; c < s.length; c++) {
      const R = c * (l + h);
      if (g.drawImage(s[c], 0, R), c < s.length - 1) {
        const S = R + l + h / 2, b = a / 6, x = b * 2, m = a / 2;
        g.save(), g.globalAlpha = 0.05, g.beginPath(), g.moveTo(m, S + b / 2), g.lineTo(m + x / 2, S - b / 2), g.lineTo(m - x / 2, S - b / 2), g.closePath(), g.fillStyle = "#000", g.fill(), g.restore();
      }
    }
    const v = g.getImageData(0, 0, a, u).data;
    return Li.encode([v.buffer], a, u, 0);
  } else {
    const h = e.length > 1 ? 2 * n : 0, u = [];
    for (let d = 0; d < s.length; d++) {
      d === 0 && (l += h);
      const g = document.createElement("canvas"), v = g.getContext("2d");
      if (!v)
        throw new Error("Could not get 2d context for canvas element.");
      const c = s[d];
      if (g.width = c.width, g.height = c.height + h, v.drawImage(c, 0, 0), h > 0) {
        v.fillStyle = "#fff", v.fillRect(0, c.height, g.width, h);
        const S = f * n, b = h / 2, x = (g.width - 2 * S) / e.length;
        v.fillStyle = "#ccc", v.fillRect(S, c.height, g.width - 2 * S, b), v.fillStyle = "#000", v.fillRect(S + x * d, c.height, x, b);
      }
      const R = v.getImageData(0, 0, a, g.height).data;
      u.push(R.buffer);
    }
    return Li.encode(
      t.randomizeOrder ? _1(u) : u,
      a,
      l,
      0,
      e.map(() => t.frameDelay ?? 250)
    );
  }
}
function E1(e) {
  const r = new Set(e.map((h) => h.slice(0, 6)));
  if (r.size !== 1)
    throw new Error("conflicting/variable filetype/encodings/sizes");
  const t = [...r][0];
  if (t.slice(0, 2) !== "B$")
    throw new Error("fixed header not found, expected B$");
  if (!of.has(t[2]))
    throw new Error(`bad encoding: ${t[2]}`);
  const i = t[2], f = t[3];
  if (!/^[A-Z]$/.test(f))
    throw new Error("fileType must be a single uppercase letter");
  const n = parseInt(t.slice(4, 6), 36);
  if (n < 1)
    throw new Error("zero parts?");
  const a = /* @__PURE__ */ new Map();
  for (const h of e) {
    const u = parseInt(h.slice(6, 8), 36);
    if (u >= n)
      throw new Error(`got part ${u} but only expecting ${n}`);
    if (a.has(u) && a.get(u) !== h.slice(8))
      throw new Error(`Duplicate part 0x${u.toString(16)} has wrong content`);
    a.set(u, h.slice(8));
  }
  const l = [];
  for (let h = 0; h < n; h++) {
    const u = a.get(h);
    if (!u)
      throw new Error(`Part ${h} is missing`);
    l.push(u);
  }
  const s = w1(l, i);
  return { fileType: f, encoding: i, raw: s };
}
function b1(e, r, t) {
  const i = ff[t], f = g1(e) - rf, n = f - f % i, a = Math.ceil(r / n);
  return a === 1 ? { count: 1, perEach: r } : {
    count: (a - 1) * n + f >= r ? a : a + 1,
    perEach: n
  };
}
function p1(e, r) {
  const t = [];
  for (let i = r.minVersion; i <= r.maxVersion; i++) {
    const { count: f, perEach: n } = b1(i, e, r.encoding);
    r.minSplit <= f && f <= r.maxSplit && t.push({ version: i, count: f, perEach: n });
  }
  if (!t.length)
    throw new Error("Cannot make it fit");
  return t.sort((i, f) => i.count - f.count || i.version - f.version), t[0];
}
function k1(e, r, t = {}) {
  if (!/^[A-Z]$/.test(r))
    throw new Error("fileType must be a single uppercase letter A-Z");
  const i = d1(t), { encoding: f, encoded: n } = v1(e, i.encoding), { version: a, count: l, perEach: s } = p1(n.length, i), h = [];
  for (let u = 0, d = 0; d < n.length; u++, d += s)
    h.push(
      `B$${f}${r}` + Ea(l) + Ea(u) + n.slice(d, d + s)
    );
  return { version: a, parts: h, encoding: f };
}
async function m1(e) {
  let r, t;
  if (e instanceof File && (e = await c1(e)), e instanceof Uint8Array) {
    if (r = e, ya(e))
      return console.debug('Detected type "P" from binary input'), { fileType: "P", raw: r };
    if (r[0] === 1 || r[0] === 2)
      return console.debug('Detected type "T" from binary input'), { fileType: "T", raw: r };
    try {
      t = new TextDecoder("utf-8", { fatal: !0 }).decode(r);
    } catch {
      return console.debug('Detected type "B" from binary input'), { fileType: "B", raw: r };
    }
  } else if (typeof e == "string")
    t = e;
  else
    throw new Error("Invalid input - must be a File, Uint8Array or string");
  const i = t.trim();
  if (/^70736274ff[0-9A-Fa-f]+$/.test(i))
    return console.debug('Detected type "P" from hex input'), { fileType: "P", raw: zr(i) };
  if (/^0[1,2]000000[0-9A-Fa-f]+$/.test(i))
    return console.debug('Detected type "T" from hex input'), { fileType: "T", raw: zr(i) };
  if (/^[A-Za-z0-9+/=]+$/.test(i)) {
    const f = u1(t);
    if (ya(f))
      return console.debug('Detected type "P" from base64 input'), { fileType: "P", raw: f };
    if (f[0] === 1 || f[0] === 2)
      return console.debug('Detected type "T" from base64 input'), { fileType: "T", raw: f };
  }
  r = r ?? new TextEncoder().encode(t);
  try {
    return JSON.parse(t), console.debug('Detected type "J"'), { fileType: "J", raw: r };
  } catch {
    return console.debug('Detected type "U"'), { fileType: "U", raw: r };
  }
}
export {
  m1 as detectFileType,
  E1 as joinQRs,
  x1 as renderQRImage,
  k1 as splitQRs
};
